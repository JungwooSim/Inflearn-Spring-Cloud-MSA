{"version":3,"file":"grafanaPlugin.1f65f885c5a67f13d9d6.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/grafana/types.ts","webpack://grafana/./public/app/plugins/datasource/grafana/components/AnnotationQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/datasource.ts","webpack://grafana/./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/module.ts"],"sourcesContent":["import { DataQuery } from '@grafana/data';\nimport { LiveDataFilter } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  LiveMeasurements = 'measurements',\n  Annotations = 'annotations',\n\n  // backend\n  RandomWalk = 'randomWalk',\n  List = 'list',\n  Read = 'read',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  filter?: LiveDataFilter;\n  buffer?: number;\n  path?: string; // for list and read\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends GrafanaQuery {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n","import React from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, FieldSet, Select, Switch } from '@grafana/ui';\nimport { css } from '@emotion/css';\n\nimport { TagFilter } from 'app/core/components/TagFilter/TagFilter';\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery } from '../types';\nimport { getAnnotationTags } from 'app/features/annotations/api';\n\nconst matchTooltipContent = 'Enabling this returns annotations that match any of the tags specified below';\n\nconst tagsTooltipContent = (\n  <div>Specify a list of tags to match. To specify a key and value tag use `key:value` syntax.</div>\n);\n\nconst annotationTypes = [\n  {\n    label: 'Dashboard',\n    value: GrafanaAnnotationType.Dashboard,\n    description: 'Query for events created on this dashboard and show them in the panels where they where created',\n  },\n  {\n    label: 'Tags',\n    value: GrafanaAnnotationType.Tags,\n    description: 'This will fetch any annotation events that match the tags filter',\n  },\n];\n\nconst limitOptions = [10, 50, 100, 200, 300, 500, 1000, 2000].map((limit) => ({\n  label: String(limit),\n  value: limit,\n}));\n\ninterface Props {\n  query: GrafanaQuery;\n  onChange: (newValue: GrafanaAnnotationQuery) => void;\n}\n\nexport default function AnnotationQueryEditor({ query, onChange }: Props) {\n  const annotationQuery = query as GrafanaAnnotationQuery;\n  const { limit, matchAny, tags, type } = annotationQuery;\n  const styles = getStyles();\n\n  const onFilterByChange = (newValue: SelectableValue<GrafanaAnnotationType>) =>\n    onChange({\n      ...annotationQuery,\n      type: newValue.value!,\n    });\n\n  const onMaxLimitChange = (newValue: SelectableValue<number>) =>\n    onChange({\n      ...annotationQuery,\n      limit: newValue.value!,\n    });\n\n  const onMatchAnyChange = (newValue: React.ChangeEvent<HTMLInputElement>) =>\n    onChange({\n      ...annotationQuery,\n      matchAny: newValue.target.checked,\n    });\n\n  const onTagsChange = (tags: string[]) =>\n    onChange({\n      ...annotationQuery,\n      tags,\n    });\n\n  const onFormatCreateLabel = (input: string) => `Use custom value: ${input}`;\n\n  return (\n    <FieldSet className={styles.container}>\n      <Field label=\"Filter by\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__filter-by\"\n          options={annotationTypes}\n          value={type}\n          onChange={onFilterByChange}\n        />\n      </Field>\n      <Field label=\"Max limit\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__limit\"\n          width={16}\n          options={limitOptions}\n          value={limit}\n          onChange={onMaxLimitChange}\n        />\n      </Field>\n      {type === GrafanaAnnotationType.Tags && tags && (\n        <>\n          <Field label=\"Match any\" description={matchTooltipContent}>\n            <Switch id=\"grafana-annotations__match-any\" value={matchAny} onChange={onMatchAnyChange} />\n          </Field>\n          <Field label=\"Tags\" description={tagsTooltipContent}>\n            <TagFilter\n              allowCustomValue\n              formatCreateLabel={onFormatCreateLabel}\n              inputId=\"grafana-annotations__tags\"\n              onChange={onTagsChange}\n              tagOptions={getAnnotationTags}\n              tags={tags}\n            />\n          </Field>\n        </>\n      )}\n    </FieldSet>\n  );\n}\n\nconst getStyles = () => {\n  return {\n    container: css`\n      max-width: 600px;\n    `,\n  };\n};\n","import { from, merge, Observable, of } from 'rxjs';\nimport { DataSourceWithBackend, getBackendSrv, getGrafanaLiveSrv, getTemplateSrv } from '@grafana/runtime';\nimport {\n  AnnotationQuery,\n  AnnotationQueryRequest,\n  DataFrameView,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceRef,\n  isValidLiveChannelAddress,\n  parseLiveChannelAddress,\n  StreamingFrameOptions,\n  toDataFrame,\n} from '@grafana/data';\n\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery, GrafanaQueryType } from './types';\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\nimport { isString } from 'lodash';\nimport { migrateDatasourceNameToRef } from 'app/features/dashboard/state/DashboardMigrator';\nimport { map } from 'rxjs/operators';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceWithBackend<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n      prepareAnnotation(json: any): AnnotationQuery<GrafanaAnnotationQuery> {\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = json.target ?? {\n          type: json.type ?? GrafanaAnnotationType.Dashboard,\n          limit: json.limit ?? 100,\n          tags: json.tags ?? [],\n          matchAny: json.matchAny ?? false,\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n        return json;\n      },\n      prepareQuery(anno: AnnotationQuery<GrafanaAnnotationQuery>): GrafanaQuery {\n        let datasource: DataSourceRef | undefined | null = undefined;\n        if (isString(anno.datasource)) {\n          const ref = migrateDatasourceNameToRef(anno.datasource);\n          if (ref) {\n            datasource = ref;\n          }\n        } else {\n          datasource = anno.datasource as DataSourceRef;\n        }\n\n        return { ...anno, refId: anno.name, queryType: GrafanaQueryType.Annotations, datasource };\n      },\n    };\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const results: Array<Observable<DataQueryResponse>> = [];\n    const targets: GrafanaQuery[] = [];\n    const templateSrv = getTemplateSrv();\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(\n          this.getAnnotations({\n            range: request.range,\n            rangeRaw: request.range.raw,\n            annotation: (target as unknown) as AnnotationQuery<GrafanaAnnotationQuery>,\n            dashboard: getDashboardSrv().getCurrent(),\n          })\n        );\n      }\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const { filter } = target;\n\n        // Help migrate pre-release channel paths saved in dashboards\n        // NOTE: this should be removed before V8 is released\n        if (channel && channel.startsWith('telegraf/')) {\n          channel = 'stream/' + channel;\n          target.channel = channel; // mutate the current query object so it is saved with `stream/` prefix\n        }\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: StreamingFrameOptions = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        results.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        if (!target.queryType) {\n          target.queryType = GrafanaQueryType.RandomWalk;\n        }\n        targets.push(target);\n      }\n    }\n\n    if (targets.length) {\n      results.push(\n        super.query({\n          ...request,\n          targets,\n        })\n      );\n    }\n\n    if (results.length) {\n      // With a single query just return the results\n      if (results.length === 1) {\n        return results[0];\n      }\n      return merge(...results);\n    }\n    return of(); // nothing\n  }\n\n  listFiles(path: string): Observable<DataFrameView<FileElement>> {\n    return this.query({\n      targets: [\n        {\n          refId: 'A',\n          queryType: GrafanaQueryType.List,\n          path,\n        },\n      ],\n    } as any).pipe(\n      map((v) => {\n        const frame = v.data[0] ?? toDataFrame({});\n        return new DataFrameView<FileElement>(frame);\n      })\n    );\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options: AnnotationQueryRequest<GrafanaQuery>): Promise<DataQueryResponse> {\n    const templateSrv = getTemplateSrv();\n    const annotation = (options.annotation as unknown) as AnnotationQuery<GrafanaAnnotationQuery>;\n    const target = annotation.target!;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny,\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({ data: [] });\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({ data: [] });\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n    return { data: [toDataFrame(annotations)] };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\nexport interface FileElement {\n  name: string;\n  ['media-type']: string;\n}\n","import React, { PureComponent } from 'react';\nimport { InlineField, Select, Alert, Input, InlineFieldRow } from '@grafana/ui';\nimport {\n  QueryEditorProps,\n  SelectableValue,\n  dataFrameFromJSON,\n  rangeUtil,\n  DataQueryRequest,\n  DataFrame,\n} from '@grafana/data';\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\nimport { getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n  folders?: Array<SelectableValue<string>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n    {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources',\n    },\n  ];\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  loadFolderInfo() {\n    const query: DataQueryRequest<GrafanaQuery> = {\n      targets: [{ queryType: GrafanaQueryType.List, refId: 'A' }],\n    } as any;\n\n    getDataSourceSrv()\n      .get('-- Grafana --')\n      .then((ds) => {\n        const gds = ds as GrafanaDatasource;\n        gds.query(query).subscribe({\n          next: (rsp) => {\n            if (rsp.data.length) {\n              const names = (rsp.data[0] as DataFrame).fields[0];\n              const folders = names.values.toArray().map((v) => ({\n                value: v,\n                label: v,\n              }));\n              this.setState({ folders });\n            }\n          },\n        });\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateBuffer = (txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let buffer: number | undefined;\n    if (txt) {\n      try {\n        buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n      } catch (err) {\n        console.warn('ERROR', err);\n      }\n    }\n    onChange({\n      ...query,\n      buffer,\n    });\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateBuffer((e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateBuffer(e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                menuShouldPortal\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  onFolderChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, path: sel?.value });\n    onRunQuery();\n  };\n\n  renderListPublicFiles() {\n    let { path } = this.props.query;\n    let { folders } = this.state;\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n    const currentFolder = folders.find((f) => f.value === path);\n    if (path && !currentFolder) {\n      folders = [\n        ...folders,\n        {\n          value: path,\n          label: path,\n        },\n      ];\n    }\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Path\" grow={true} labelWidth={labelWidth}>\n          <Select\n            menuShouldPortal\n            options={folders}\n            value={currentFolder || ''}\n            onChange={this.onFolderChanged}\n            allowCustomValue={true}\n            backspaceRemovesValue={true}\n            placeholder=\"Select folder\"\n            isClearable={true}\n            formatCreateLabel={(input: string) => `Folder: ${input}`}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    return (\n      <>\n        <InlineFieldRow>\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n        {query.queryType === GrafanaQueryType.List && this.renderListPublicFiles()}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport { GrafanaDatasource } from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaQuery } from './types';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource).setQueryEditor(\n  QueryEditor\n);\n"],"names":["GrafanaQueryType","defaultQuery","refId","queryType","RandomWalk","GrafanaAnnotationType","tagsTooltipContent","annotationTypes","label","value","Dashboard","description","Tags","limitOptions","map","limit","String","AnnotationQueryEditor","query","onChange","annotationQuery","matchAny","tags","type","styles","getStyles","FieldSet","className","container","Field","Select","menuShouldPortal","inputId","options","newValue","width","Switch","id","target","checked","TagFilter","allowCustomValue","formatCreateLabel","input","tagOptions","getAnnotationTags","css","counter","GrafanaDatasource","DataSourceWithBackend","constructor","instanceSettings","super","this","annotations","QueryEditor","prepareAnnotation","json","prepareQuery","anno","datasource","isString","ref","migrateDatasourceNameToRef","name","Annotations","request","results","targets","templateSrv","getTemplateSrv","from","getAnnotations","range","rangeRaw","raw","annotation","dashboard","getDashboardSrv","getCurrent","hide","LiveMeasurements","channel","replace","scopedVars","filter","startsWith","addr","parseLiveChannelAddress","isValidLiveChannelAddress","buffer","maxLength","maxDataPoints","maxDelta","to","valueOf","push","getGrafanaLiveSrv","getDataStream","key","requestId","length","merge","of","listFiles","path","List","pipe","v","frame","data","toDataFrame","DataFrameView","metricFindQuery","Promise","resolve","params","dashboardId","Array","isArray","delimiter","t","renderedValues","join","tt","split","getBackendSrv","get","testDatasource","PureComponent","channels","channelFields","sel","onRunQuery","props","loadChannelInfo","item","fields","tf","state","find","f","txt","rangeUtil","err","console","warn","e","checkAndUpdateBuffer","fetch","url","subscribe","next","channelInfo","c","distinctFields","Set","dataFrameFromJSON","add","n","minute_rate","setState","loadFolderInfo","getDataSourceSrv","then","ds","rsp","folders","values","toArray","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","InlineField","grow","labelWidth","onChannelChange","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","onFieldNamesChange","isSearchable","isMulti","Input","defaultValue","onKeyDown","handleEnterKey","onBlur","handleBlur","spellCheck","Alert","title","severity","renderListPublicFiles","currentFolder","InlineFieldRow","onFolderChanged","render","queryTypes","onQueryTypeChange","plugin","DataSourcePlugin","setQueryEditor"],"sourceRoot":""}