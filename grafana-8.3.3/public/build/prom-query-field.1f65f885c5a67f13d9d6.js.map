{"version":3,"file":"prom-query-field.1f65f885c5a67f13d9d6.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/react-use-virtual-ca2705900f/3/opt/drone/yarncache/react-use-npm-17.2.4-c702db5427-3c885c3798.zip/node_modules/react-use/esm/useLatest.js","webpack://grafana/../../opt/drone/yarncache/monaco-promql-npm-1.7.2-7f61733ebe-54061d5c1c.zip/node_modules/monaco-promql/promql/promql.contribution.js","webpack://grafana/../../opt/drone/yarncache/lezer-tree-npm-0.13.2-b9c523856b-b8be213c78.zip/node_modules/lezer-tree/dist/tree.es.js","webpack://grafana/../../opt/drone/yarncache/lezer-npm-0.13.5-e8a02e6ffa-a5c3aa01c5.zip/node_modules/lezer/dist/index.es.js","webpack://grafana/./.yarn/__virtual__/lezer-promql-virtual-24e8a44774/3/opt/drone/yarncache/lezer-promql-npm-0.20.0-125f2ec07e-9cf76d60aa.zip/node_modules/lezer-promql/index.es.js","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/util.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/index.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/getOverrideServices.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryField.tsx"],"sourcesContent":["import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n","// The MIT License (MIT)\n//\n// Copyright (c) Celian Garcia and Augustin Husson @ Amadeus IT Group\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n'use strict';\n// noinspection JSUnusedGlobalSymbols\nexport var promLanguageDefinition = {\n    id: 'promql',\n    extensions: ['.promql'],\n    aliases: ['Prometheus', 'prometheus', 'prom', 'Prom', 'promql', 'Promql', 'promQL', 'PromQL'],\n    mimetypes: [],\n    loader: function () { return import('./promql'); } // eslint-disable-line @typescript-eslint/explicit-function-return-type\n};\n","/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nconst CachedNode = new WeakMap();\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type. You can optionally pass a\n    /// `deserialize` function.\n    constructor({ deserialize } = {}) {\n        this.id = nextPropID++;\n        this.deserialize = deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// Create a string-valued node prop whose deserialize function is\n    /// the identity function.\n    static string() { return new NodeProp({ deserialize: str => str }); }\n    /// Create a number-valued node prop whose deserialize function is\n    /// just `Number`.\n    static number() { return new NodeProp({ deserialize: Number }); }\n    /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n    static flag() { return new NodeProp({ deserialize: () => true }); }\n    /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    set(propObj, value) {\n        propObj[this.id] = value;\n        return propObj;\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the set. Takes a [match\n    /// object](#tree.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src)\n                    src[0].set(props, src[1]);\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#tree.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#tree.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#tree.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    add[0].set(newProps, add[1]);\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. You usually want to go through\n    /// [`Tree.build`](#tree.Tree^build) instead.\n    constructor(type, \n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n    }\n    /// @internal\n    toString() {\n        let children = this.children.map(c => c.toString()).join();\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n    /// nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, true);\n    }\n    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        return this.cursor(pos, side).node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, the given node\n    /// will not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor();;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Balance the direct children of this tree.\n    balance(maxBufferLength = DefaultBufferLength) {\n        return this.children.length <= BalanceBranchFactor ? this\n            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree, hash) {\n    if (hash)\n        tree.contextHash = hash;\n    return tree;\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer @internal\n    constructor(\n    /// @internal\n    buffer, \n    // The total length of the group of nodes in the buffer.\n    length, \n    /// @internal\n    set, type = NodeType.none) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n        this.type = type;\n    }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, after) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (after != -100000000 /* None */) {\n                let start = buffer[i + 1], end = buffer[i + 2];\n                if (dir > 0) {\n                    if (end > after)\n                        pick = i;\n                    if (end > after)\n                        break;\n                }\n                else {\n                    if (start < after)\n                        pick = i;\n                    if (end >= after)\n                        break;\n                }\n            }\n            else {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n}\nclass TreeNode {\n    constructor(node, from, index, _parent) {\n        this.node = node;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get to() { return this.from + this.node.length; }\n    nextChild(i, dir, after, full = false) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if (full || (!next.type.isAnonymous || hasChild(next))) {\n                    let inner = new TreeNode(next, start, i, parent);\n                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);\n                }\n            }\n            if (full || !parent.type.isAnonymous)\n                return null;\n            i = parent.index + dir;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;\n    }\n    get prevSibling() {\n        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, after) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, -100000000 /* None */); }\n    get lastChild() { return this.child(-1, -100000000 /* None */); }\n    childAfter(pos) { return this.child(1, pos); }\n    childBefore(pos) { return this.child(-1, pos); }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, full = false) {\n        this.full = full;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enter(dir, after) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enter(1, -100000000 /* None */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enter(-1, -100000000 /* None */); }\n    /// Move the cursor to the first child that starts at or after `pos`.\n    childAfter(pos) { return this.enter(1, pos); }\n    /// Move to the last child that ends at or before `pos`.\n    childBefore(pos) { return this.enter(-1, pos); }\n    /// Move the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                let child = parent.node.children[i];\n                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))\n                    return false;\n            }\n        }\n        return true;\n    }\n    move(dir) {\n        if (this.enter(dir, -100000000 /* None */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty, its next sibling or the next sibling of\n    /// the first parent node that has one.\n    next() { return this.move(1); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by ist last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev() { return this.move(-1); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        for (;;) {\n            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))\n                break;\n            if (this.from == this.to ||\n                (side < 1 ? this.from >= pos : this.from > pos) ||\n                (side > -1 ? this.to <= pos : this.to < pos)) {\n                this.parent();\n                break;\n            }\n        }\n        return this;\n    }\n    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#tree.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#tree.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));\n}\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\nconst BalanceBranchFactor = 8;\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let startPos = start - parentStart;\n        if (size < 0) {\n            if (size == -1) { // Reused node\n                children.push(reused[id]);\n                positions.push(startPos);\n            }\n            else { // Context change\n                contextHash = id;\n            }\n            cursor.next();\n            return;\n        }\n        let type = types[id], node, buffer;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index, inRepeat);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            while (cursor.pos > endPos) {\n                if (cursor.id == localInRepeat)\n                    cursor.next();\n                else\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n            }\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);\n            else\n                node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let nodeSize = fork.size, startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0)\n                    break scan;\n                if (fork.id >= minRepeatType)\n                    localSkipped += 4;\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index, inRepeat) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (id == inRepeat)\n            return index;\n        let startIndex = index;\n        if (size > 4) {\n            let endPos = cursor.pos - (size - 4);\n            while (cursor.pos > endPos)\n                index = copyToBuffer(bufferStart, buffer, index, inRepeat);\n        }\n        if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {\n    let localChildren = [], localPositions = [];\n    if (length <= maxBufferLength) {\n        for (let i = from; i < to; i++) {\n            localChildren.push(children[i]);\n            localPositions.push(positions[i] - start);\n        }\n    }\n    else {\n        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i];\n            i++;\n            for (; i < to; i++) {\n                let nextEnd = positions[i] + children[i].length;\n                if (nextEnd - groupStart > maxChild)\n                    break;\n            }\n            if (i == groupFrom + 1) {\n                let only = children[groupFrom];\n                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n                    for (let j = 0; j < only.children.length; j++) {\n                        localChildren.push(only.children[j]);\n                        localPositions.push(only.positions[j] + groupStart - start);\n                    }\n                    continue;\n                }\n                localChildren.push(only);\n            }\n            else if (i == groupFrom + 1) {\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);\n                if (innerType != NodeType.none && !containsType(inner.children, innerType))\n                    inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);\n                localChildren.push(inner);\n            }\n            localPositions.push(groupStart - start);\n        }\n    }\n    return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);\n}\nfunction containsType(nodes, type) {\n    for (let elt of nodes)\n        if (elt.type == type)\n            return true;\n    return false;\n}\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nclass TreeFragment {\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, open) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = open;\n    }\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        let cI = 0, pos = 0, off = 0;\n        for (;;) {\n            let nextC = cI < changes.length ? changes[cI++] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null :\n                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the token at its\n    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n}\n// Creates an `Input` that is backed by a single, flat string.\nfunction stringInput(input) { return new StringInput(input); }\nclass StringInput {\n    constructor(string, length = string.length) {\n        this.string = string;\n        this.length = length;\n    }\n    get(pos) {\n        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n    }\n    lineAfter(pos) {\n        if (pos < 0)\n            return \"\";\n        let end = this.string.indexOf(\"\\n\", pos);\n        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));\n    }\n    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }\n    clip(at) { return new StringInput(this.string, at); }\n}\n\nexport { DefaultBufferLength, NodeProp, NodeSet, NodeType, Tree, TreeBuffer, TreeCursor, TreeFragment, stringInput };\n//# sourceMappingURL=tree.es.js.map\n","import { DefaultBufferLength, NodeSet, NodeType, stringInput, Tree, TreeBuffer } from 'lezer-tree';\nexport { NodeProp, NodeSet, NodeType, Tree, TreeCursor } from 'lezer-tree';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// A the parse that this stack is part of @internal\n    p, \n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null);\n    }\n    /// The stack's current [context](#lezer.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            // Zero-depth reductions are a special casethey add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            this.reduceContext(type);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let start = this.pos, nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n            this.shiftContext(next);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, this.pos, nextEnd, 4);\n            this.pos = nextEnd;\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt node into the buffer. This may be a reused node or\n    // the result of running a nested parser.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 200 /* Token */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    /// Find the start position of the rule that is currently being parsed.\n    get ruleStart() {\n        for (let state = this.state, base = this.stack.length;;) {\n            let force = this.p.parser.stateSlot(state, 5 /* ForcedReduce */);\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            base -= 3 * (force >> 19 /* ReduceDepthShift */);\n            if ((force & 65535 /* ValueMask */) < this.p.parser.minRepeatTerm)\n                return this.stack[base + 1];\n            state = this.stack[base];\n        }\n    }\n    /// Find the start position of an instance of any of the given term\n    /// types, or return `null` when none of them are found.\n    ///\n    /// **Note:** this is only reliable when there is at least some\n    /// state that unambiguously matches the given rule on the stack.\n    /// I.e. if you have a grammar like this, where the difference\n    /// between `a` and `b` is only apparent at the third token:\n    ///\n    ///     a { b | c }\n    ///     b { \"x\" \"y\" \"x\" }\n    ///     c { \"x\" \"y\" \"z\" }\n    ///\n    /// Then a parse state after `\"x\"` will not reliably tell you that\n    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n    /// for either of those two rules (assuming that `a` isn't part of\n    /// some rule that includes other things starting with `\"x\"`).\n    ///\n    /// When `before` is given, this keeps scanning up the stack until\n    /// it finds a match that starts before that position.\n    ///\n    /// Note that you have to be careful when using this in tokenizers,\n    /// since it's relatively easy to introduce data dependencies that\n    /// break incremental parsing by using this method.\n    startOf(types, before) {\n        let state = this.state, frame = this.stack.length, { parser } = this.p;\n        for (;;) {\n            let force = parser.stateSlot(state, 5 /* ForcedReduce */);\n            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;\n            if (types.indexOf(term) > -1) {\n                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];\n                if (before == null || before > pos)\n                    return pos;\n            }\n            if (frame == 0)\n                return null;\n            if (depth == 0) {\n                frame -= 3;\n                state = this.stack[frame];\n            }\n            else {\n                frame -= 3 * (depth - 1);\n                state = parser.getGoto(this.stack[frame - 3], term, true);\n            }\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i]);\n            stack.score -= 200 /* Token */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        if (!this.p.parser.validAction(this.state, reduce)) {\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this));\n    }\n    reduceContext(term) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this));\n    }\n    /// @internal\n    emitContext() {\n        let cx = this.curContext;\n        if (!cx.tracker.strict)\n            return;\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -2)\n            this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.hash(context);\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Token\"] = 200] = \"Token\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n/// Tokenizers write the tokens they read into instances of this class.\nclass Token {\n    constructor() {\n        /// The start of the token. This is set by the parser, and should not\n        /// be mutated by the tokenizer.\n        this.start = -1;\n        /// This starts at -1, and should be updated to a term id when a\n        /// matching token is found.\n        this.value = -1;\n        /// When setting `.value`, you should also set `.end` to the end\n        /// position of the token. (You'll usually want to use the `accept`\n        /// method.)\n        this.end = -1;\n    }\n    /// Accept a token, setting `value` and `end` to the given values.\n    accept(value, end) {\n        this.value = value;\n        this.end = end;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// Exports that are used for `@external tokens` in the grammar should\n/// export an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream and a token object,\n    /// [fills](#lezer.Token.accept) the token object if it recognizes a\n    /// token. `token.start` should be used as the start position to\n    /// scan from.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, token, stack, group) {\n    let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect;\n    scan: for (let pos = token.start;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {\n                    token.accept(term, pos);\n                    break;\n                }\n            }\n        let next = input.get(pos++);\n        // Do a binary search on the state's edges\n        for (let low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        this.fragments = fragments;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            else if (start == pos && start + next.length <= this.safeTo) {\n                return start == pos && start >= this.safeFrom ? next : null;\n            }\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    }\n}\nclass CachedToken extends Token {\n    constructor() {\n        super(...arguments);\n        this.extended = -1;\n        this.mask = 0;\n        this.context = 0;\n    }\n    clear(start) {\n        this.start = start;\n        this.value = this.extended = -1;\n    }\n}\nconst dummyToken = new Token;\nclass TokenCache {\n    constructor(parser) {\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack, input) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack, input);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (!main) {\n            main = dummyToken;\n            main.start = stack.pos;\n            if (stack.pos == input.length)\n                main.accept(stack.p.parser.eofTerm, stack.pos);\n            else\n                main.accept(0 /* Err */, stack.pos + 1);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    updateCachedToken(token, tokenizer, stack, input) {\n        token.clear(stack.pos);\n        tokenizer.token(input, token, stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](input.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else if (stack.pos == input.length) {\n            token.accept(stack.p.parser.eofTerm, stack.pos);\n        }\n        else {\n            token.accept(0 /* Err */, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 1), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    Rec[Rec[\"MinBufferLengthPrune\"] = 200] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n})(Rec || (Rec = {}));\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nclass Parse {\n    constructor(parser, input, startPos, context) {\n        this.parser = parser;\n        this.input = input;\n        this.startPos = startPos;\n        this.context = context;\n        // The position to which the parse has advanced.\n        this.pos = 0;\n        this.recovering = 0;\n        this.nextStackID = 0x2654;\n        this.nested = null;\n        this.nestEnd = 0;\n        this.nestWrap = null;\n        this.reused = [];\n        this.tokens = new TokenCache(parser);\n        this.topTerm = parser.top[1];\n        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];\n        let fragments = context === null || context === void 0 ? void 0 : context.fragments;\n        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        if (this.nested) {\n            let result = this.nested.advance();\n            this.pos = this.nested.pos;\n            if (result) {\n                this.finishNested(this.stacks[0], result);\n                this.nested = null;\n            }\n            return null;\n        }\n        let stacks = this.stacks, pos = this.pos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        let maybeNest;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], nest;\n            for (;;) {\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (nest = this.checkNest(stack)) {\n                    if (!maybeNest || maybeNest.stack.score < stack.score)\n                        maybeNest = nest;\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.mainToken;\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (maybeNest) {\n            this.startNested(maybeNest);\n            return null;\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.pos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.pos)\n                this.pos = newStacks[i].pos;\n        return null;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { input, parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.contextHash || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        let actions = this.tokens.getActions(stack, input);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            let nest = this.checkNest(stack);\n            if (nest)\n                return nest;\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        let maybeNest;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) {\n                    if (done !== true)\n                        maybeNest = done;\n                    continue;\n                }\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) {\n                    if (done !== true)\n                        maybeNest = done;\n                    break;\n                }\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.input.length > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        if (finished)\n            return finished;\n        if (maybeNest)\n            for (let s of this.stacks)\n                if (s.score > maybeNest.stack.score) {\n                    maybeNest = undefined;\n                    break;\n                }\n        if (maybeNest)\n            this.startNested(maybeNest);\n        return null;\n    }\n    forceFinish() {\n        let stack = this.stacks[0].split();\n        if (this.nested)\n            this.finishNested(stack, this.nested.forceFinish());\n        return this.stackToTree(stack.forceAll());\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack, pos = stack.pos) {\n        if (this.parser.context)\n            stack.emitContext();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.startPos,\n            length: pos - this.startPos,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    checkNest(stack) {\n        let info = this.parser.findNested(stack.state);\n        if (!info)\n            return null;\n        let spec = info.value;\n        if (typeof spec == \"function\")\n            spec = spec(this.input, stack);\n        return spec ? { stack, info, spec } : null;\n    }\n    startNested(nest) {\n        let { stack, info, spec } = nest;\n        this.stacks = [stack];\n        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);\n        this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;\n        if (spec.startParse) {\n            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);\n        }\n        else {\n            this.finishNested(stack);\n        }\n    }\n    scanForNestEnd(stack, endToken, filter) {\n        for (let pos = stack.pos; pos < this.input.length; pos++) {\n            dummyToken.start = pos;\n            dummyToken.value = -1;\n            endToken.token(this.input, dummyToken, stack);\n            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))\n                return pos;\n        }\n        return this.input.length;\n    }\n    finishNested(stack, tree) {\n        if (this.nestWrap)\n            tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);\n        else if (!tree)\n            tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos);\n        let info = this.parser.findNested(stack.state);\n        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));\n        if (verbose)\n            console.log(this.stackID(stack) + ` (via unnest)`);\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\nclass ContextTracker {\n    /// The export used in a `@context` declaration should be of this\n    /// type.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash;\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass Parser {\n    /// @internal\n    constructor(spec) {\n        /// @internal\n        this.bufferLength = DefaultBufferLength;\n        /// @internal\n        this.strict = false;\n        this.cachedDialect = null;\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let tokenArray = decodeArray(spec.tokenData);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        this.context = spec.context;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };\n        });\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    /// Parse a given string or stream.\n    parse(input, startPos = 0, context = {}) {\n        if (typeof input == \"string\")\n            input = stringInput(input);\n        let cx = new Parse(this, input, startPos, context);\n        for (;;) {\n            let done = cx.advance();\n            if (done)\n                return done;\n        }\n    }\n    /// Start an incremental parse.\n    startParse(input, startPos = 0, context = {}) {\n        if (typeof input == \"string\")\n            input = stringInput(input);\n        return new Parse(this, input, startPos, context);\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    findNested(state) {\n        let flags = this.stateSlot(state, 0 /* Flags */);\n        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(Parser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.nested)\n            copy.nested = this.nested.map(obj => {\n                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))\n                    return obj;\n                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };\n            });\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// Tells you whether this grammar has any nested grammars.\n    get hasNested() { return this.nested.length > 0; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        if (this.cachedDialect && this.cachedDialect.source == dialect)\n            return this.cachedDialect;\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return this.cachedDialect = new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new Parser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        if (stack.pos == stack.p.input.length &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexport { ContextTracker, ExternalTokenizer, Parser, Stack, Token };\n//# sourceMappingURL=index.es.js.map\n","import { Parser } from 'lezer';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst \n  inf = 130,\n  nan = 131,\n  Bool = 1,\n  Ignoring = 2,\n  On = 3,\n  GroupLeft = 4,\n  GroupRight = 5,\n  Offset = 6,\n  Avg = 7,\n  Bottomk = 8,\n  Count = 9,\n  CountValues = 10,\n  Group = 11,\n  Max = 12,\n  Min = 13,\n  Quantile = 14,\n  Stddev = 15,\n  Stdvar = 16,\n  Sum = 17,\n  Topk = 18,\n  By = 19,\n  Without = 20,\n  And = 21,\n  Or = 22,\n  Unless = 23,\n  Start = 24,\n  End = 25;\n\n// Copyright 2021 PromLabs GmbH\n\nconst keywordTokens = {\n  inf: inf,\n  nan: nan,\n  bool: Bool,\n  ignoring: Ignoring,\n  on: On,\n  group_left: GroupLeft,\n  group_right: GroupRight,\n  offset: Offset,\n};\n\nconst specializeIdentifier = (value, stack) => {\n  return keywordTokens[value.toLowerCase()] || -1;\n};\n\nconst contextualKeywordTokens = {\n  avg: Avg,\n  bottomk: Bottomk,\n  count: Count,\n  count_values: CountValues,\n  group: Group,\n  max: Max,\n  min: Min,\n  quantile: Quantile,\n  stddev: Stddev,\n  stdvar: Stdvar,\n  sum: Sum,\n  topk: Topk,\n  by: By,\n  without: Without,\n  and: And,\n  or: Or,\n  unless: Unless,\n  start: Start,\n  end: End,\n};\n\nconst extendIdentifier = (value, stack) => {\n  return contextualKeywordTokens[value.toLowerCase()] || -1;\n};\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_Identifier = {__proto__:null,absent_over_time:275, absent:277, abs:279, avg_over_time:281, ceil:283, changes:285, clamp:287, clamp_max:289, clamp_min:291, count_over_time:293, days_in_month:295, day_of_month:297, day_of_week:299, delta:301, deriv:303, exp:305, floor:307, histogram_quantile:309, holt_winters:311, hour:313, idelta:315, increase:317, irate:319, label_replace:321, label_join:323, last_over_time:325, ln:327, log10:329, log2:331, max_over_time:333, min_over_time:335, minute:337, month:339, predict_linear:341, present_over_time:343, quantile_over_time:345, rate:347, resets:349, round:351, scalar:353, sgn:355, sort:357, sort_desc:359, sqrt:361, stddev_over_time:363, stdvar_over_time:365, sum_over_time:367, timestamp:369, time:371, vector:373, year:375};\nconst parser = Parser.deserialize({\n  version: 13,\n  states: \"4^OYQPOOO%|QPOOOOQO'#Cz'#CzO&RQPO'#CyQ&^QQOOOOQO'#Dd'#DdO&XQPO'#DcOOQO'#Em'#EmO'hQPO'#EsOYQPO'#EoOYQPO'#ErOOQO'#Eu'#EuO,eQSO'#EvO,mQQO'#EtOOQO'#Et'#EtOOQO'#Cx'#CxOOQO'#De'#DeOOQO'#Dg'#DgOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjQOQPOOO.TQPO'#C{O.YQPO'#DQO&XQPO,59eO.aQQO,59eO/zQPO,59nO/zQPO,59nO/zQPO,59nO/zQPO,59nO/zQPO,59nO4wQQO,5;VO4|QQO,5;YO5UQPO,5;iOOQO,59},59}OOQO,5;X,5;XO5mQQO,5;ZO5tQQO,5;^O7XQPO'#ExO7gQPO,5;bOOQO'#Ew'#EwOOQO,5;b,5;bOOQO,5;`,5;`O7oQSO'#C|OOQO,59g,59gO7wQPO,59lO8PQQO'#DROOQO,59l,59lOOQO1G/P1G/PO.TQPO'#DVO<}QPO'#DUO=XQPO'#DUOYQPO1G/YOYQPO1G/YOYQPO1G/YOYQPO1G/YOYQPO1G/YO=cQSO1G0qOOQO1G0t1G0tO=kQQO1G0tO=pQPO'#EmOOQO'#FP'#FPOOQO1G1T1G1TO={QPO1G1TOOQO1G0u1G0uOOQO'#Ey'#EyO>QQPO,5;dO>VQSO1G0|OOQO1G0|1G0|OOQO'#DO'#DOO>_QPO,59hOOQO'#C}'#C}OOQO,59h,59hOYQPO,59mOOQO1G/W1G/WOOQO,59q,59qOCWQPO,59pOC_QPO,59pODvQQO7+$tOETQQO7+$tOFcQQO7+$tOFyQQO7+$tOH_QQO7+$tOOQO7+&]7+&]OHxQQO7+&cOOQO7+&`7+&`OIQQPO7+&oOOQO1G1O1G1OOOQO1G0}1G0}OOQO7+&h7+&hOIVQSO1G/SOOQO1G/S1G/SOI_QQO1G/XOOQO1G/[1G/[OIiQPO1G/[OOQO<<I}<<I}ON]QPO<<I}OOQO<<JZ<<JZOOQO1G/T1G/TOOQO7+$n7+$nOOQO7+$v7+$vOOQOAN?iAN?i\",\n  stateData: \"Nb~O#yOSjOS~OVQOWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQO!YZO#d_O#vVO#wVO#zXO#}`O$OaO$PbO$QcO$RdO$SeO$TfO$UgO$VhO$WiO$XjO$YkO$ZlO$[mO$]nO$^oO$_pO$`qO$arO$bsO$ctO$duO$evO$fwO$gxO$hyO$izO$j{O$k|O$l}O$m!OO$n!PO$o!QO$p!RO$q!SO$r!TO$s!UO$t!VO$u!WO$v!XO$w!YO$x!ZO$y![O$z!]O${!^O$|!_O$}!`O%O!aO%P!bO%Q!cO%R!dO%UWO%VWO%WVO%Y[O~O!YZO~Oc!fOd!fO#z!gO~OU!pOe!mOf!nOg!mOw!jOz!jO{!jO|!jO}!kO!O!kO!P!lO!Q!lO!R!lO!S!lO!T!lO!U!lO#r!qO%S!oO~O#v!sO#w!sO%W!sOV#gXW#gXX#gXY#gXZ#gX[#gX]#gX^#gX_#gX`#gXa#gXb#gX!Y#gX#d#gX#v#gX#w#gX#z#gX#}#gX$O#gX$P#gX$Q#gX$R#gX$S#gX$T#gX$U#gX$V#gX$W#gX$X#gX$Y#gX$Z#gX$[#gX$]#gX$^#gX$_#gX$`#gX$a#gX$b#gX$c#gX$d#gX$e#gX$f#gX$g#gX$h#gX$i#gX$j#gX$k#gX$l#gX$m#gX$n#gX$o#gX$p#gX$q#gX$r#gX$s#gX$t#gX$u#gX$v#gX$w#gX$x#gX$y#gX$z#gX${#gX$|#gX$}#gX%O#gX%P#gX%Q#gX%R#gX%U#gX%V#gX%W#gX%Y#gX~Os!vO%Z!yO~O%Y[OU#hXe#hXf#hXg#hXw#hXz#hX{#hX|#hX}#hX!O#hX!P#hX!Q#hX!R#hX!S#hX!T#hX!U#hX#r#hX#u#hX%S#hX#|#hX#{#hX~O#z!{O~O#|#PO~PYOc!fOd!fOUmaemafmagmawmazma{ma|ma}ma!Oma!Pma!Qma!Rma!Sma!Tma!Uma#rma#uma%Sma#|ma#{ma~OP#TOQ#ROR#ROVxPWxPXxPYxPZxP[xP]xP^xP_xP`xPaxPbxP!YxP#dxP#vxP#wxP#zxP#}xP$OxP$PxP$QxP$RxP$SxP$TxP$UxP$VxP$WxP$XxP$YxP$ZxP$[xP$]xP$^xP$_xP$`xP$axP$bxP$cxP$dxP$exP$fxP$gxP$hxP$ixP$jxP$kxP$lxP$mxP$nxP$oxP$pxP$qxP$rxP$sxP$txP$uxP$vxP$wxP$xxP$yxP$zxP${xP$|xP$}xP%OxP%PxP%QxP%RxP%UxP%VxP%WxP%YxP~O#`#ZO~O!O#]O#`#[O~Oh#_Oi#_O#vVO#wVO%U#^O%V#^O%WVO~O#|#bO~P&^Ow!jOU#fae#faf#fag#faz#fa{#fa|#fa}#fa!O#fa!P#fa!Q#fa!R#fa!S#fa!T#fa!U#fa#r#fa#u#fa%S#fa#|#fa#{#fa~O!U#cO#n#cO#o#cO#p#cO~O#{#eO%Z#fO~Os#gO#|#jO~O#{#kO#|#lO~O#{uX#|uX~P&^OVxXWxXXxXYxXZxX[xX]xX^xX_xX`xXaxXbxX!YxX#dxX#vxX#wxX#zxX#}xX$OxX$PxX$QxX$RxX$SxX$TxX$UxX$VxX$WxX$XxX$YxX$ZxX$[xX$]xX$^xX$_xX$`xX$axX$bxX$cxX$dxX$exX$fxX$gxX$hxX$ixX$jxX$kxX$lxX$mxX$nxX$oxX$pxX$qxX$rxX$sxX$txX$uxX$vxX$wxX$xxX$yxX$zxX${xX$|xX$}xX%OxX%PxX%QxX%RxX%UxX%VxX%WxX%YxX~OS#nOT#nO~P8ZOQ#ROR#RO~P8ZO%T#uO%X#vO~O#`#wO~O#v!sO#w!sO%W!sO~O#z#xO~O#d#yO~Os!vO%Z#{O~O#{#|O#|#}O~OVxaWxaXxaYxaZxa[xa]xa^xa_xa`xaaxabxa!Yxa#dxa#vxa#wxa#}xa$Oxa$Pxa$Qxa$Rxa$Sxa$Txa$Uxa$Vxa$Wxa$Xxa$Yxa$Zxa$[xa$]xa$^xa$_xa$`xa$axa$bxa$cxa$dxa$exa$fxa$gxa$hxa$ixa$jxa$kxa$lxa$mxa$nxa$oxa$pxa$qxa$rxa$sxa$txa$uxa$vxa$wxa$xxa$yxa$zxa${xa$|xa$}xa%Oxa%Pxa%Qxa%Rxa%Uxa%Vxa%Wxa%Yxa~O#z!{O~P>gOS$QOT$QO#zxa~P>gOw!jOUvqevqfvqgvq}vq!Ovq!Pvq!Qvq!Rvq!Svq!Tvq!Uvq#rvq#uvq%Svq#|vq#{vq~Ozvq{vq|vq~PClOz!jO{!jO|!jO~PClOw!jOz!jO{!jO|!jO}!kO!O!kOUvqevqfvqgvq#rvq#uvq%Svq#|vq#{vq~O!Pvq!Qvq!Rvq!Svq!Tvq!Uvq~PEbO!P!lO!Q!lO!R!lO!S!lO!T!lO!U!lO~PEbOe!mOg!mOw!jOz!jO{!jO|!jO}!kO!O!kO!P!lO!Q!lO!R!lO!S!lO!T!lO!U!lO~OUvqfvq#rvq#uvq%Svq#|vq#{vq~PGaO#`$SO%T$RO~O#|$TO~Os#gO#|$VO~O#{ui#|ui~P&^O#z!{OVxiWxiXxiYxiZxi[xi]xi^xi_xi`xiaxibxi!Yxi#dxi#vxi#wxi#}xi$Oxi$Pxi$Qxi$Rxi$Sxi$Txi$Uxi$Vxi$Wxi$Xxi$Yxi$Zxi$[xi$]xi$^xi$_xi$`xi$axi$bxi$cxi$dxi$exi$fxi$gxi$hxi$ixi$jxi$kxi$lxi$mxi$nxi$oxi$pxi$qxi$rxi$sxi$txi$uxi$vxi$wxi$xxi$yxi$zxi${xi$|xi$}xi%Oxi%Pxi%Qxi%Rxi%Uxi%Vxi%Wxi%Yxi~O%T$XO~O\",\n  goto: \"(e#tPPPPPPPPPPPPPPPPPPPPPPPPPPPP#u$e$q$}%T%a%dP%j%s$eP%v&VPPPPPPPPPPP$e&a&mP&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m&m$eP&y$e$eP$e$e'Y$e'f'u(U(X(_PPP$eP(bQSOQ!tXQ!uYQ#O!gQ#p#UQ#q#VQ#r#WQ#s#XQ#t#YR$O#ke_OXY!g#U#V#W#X#Y#keROXY!g#U#V#W#X#Y#kQ!hRR#Q!iQ!|!fQ#m#RQ$P#nR$W$QR#h!{Q#i!{R$U#|Q!iRQ!rUR#Q!hR!}!gQ#U!jQ#V!kQ#W!lQ#X!mR#Y!nY#S!j!k!l!m!nR#o#TeUOXY!g#U#V#W#X#Y#keTOXY!g#U#V#W#X#Y#kd_OXY!g#U#V#W#X#Y#kR#`!qeYOXY!g#U#V#W#X#Y#kd]OXY!g#U#V#W#X#Y#kR!ePd^OXY!g#U#V#W#X#Y#kR!z]R!w[Q!x[R#z#eR#d!vR#a!q\",\n  nodeNames: \" Bool Ignoring On GroupLeft GroupRight Offset Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs AvgOverTime Ceil Changes Clamp ClampMax ClampMin CountOverTime DaysInMonth DayOfMonth DayOfWeek Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month PredictLinear PresentOverTime QuantileOverTime Rate Resets Round Scalar Sgn Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName\",\n  maxTerm: 195,\n  skippedNodes: [0,26],\n  repeatNodeCount: 0,\n  tokenData: \"! j~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)f![!]LZ!^!_MV!_!`Md!`!aMy!b!cNW!c!}N]!}#ONs#P#QNx#Q#RN}#R#SN]#S#T! S#T#oN]#o#p! `#q#r! e#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY#y~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!U~~$tO#p~~$yU#d~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#d~~%ePO~$t~%mQj~OY%hZ~%h~%xO|~~%}U#d~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO#z~~&qO#|~~&vOz~R&}O%VP}Q~'SO#{~R'ZO%UP!OQP'^P!Q!['aP'fR%WP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%WP!Q![(R~(`O{~R(eZ%WP!O!P)W!Q![)f!g!h'o#W#X*Z#X#Y'o#[#].i#a#b0l#g#h1r#k#l2Z#l#mKo#m#n:pP)]R%WP!Q![)W!g!h'o#X#Y'oR)kY%WP!O!P)W!Q![)f!g!h'o#W#X*Z#X#Y'o#[#].i#a#b0l#g#h1r#k#l2Z#m#n:pQ*`P#`Q!Q![*cQ*fS!Q![*c#[#]*r#a#b,z#g#h.QQ*wP#`Q!Q![*zQ*}R!Q![*z#a#b+W#g#h,cQ+]Q#`Q!Q![+c#g#h+uQ+fR!Q![+c#a#b+o#g#h+zQ+rP#g#h+uQ+zO#`QQ,PP#`Q!Q![,SQ,VQ!Q![,S#a#b,]Q,`P#g#h+uQ,hP#`Q!Q![,kQ,nQ!Q![,k#a#b,tQ,wP#g#h+uQ-PQ#`Q!Q![-V#g#h+uQ-YR!Q![-V#a#b-c#g#h-iQ-fP#g#h+uQ-nP#`Q!Q![-qQ-tQ!Q![-q#a#b-zQ-}P#g#h+uQ.VP#`Q!Q![.YQ.]Q!Q![.Y#a#b.cQ.fP#g#h+uQ.nP#`Q!Q![.qQ.tR!Q![.q#a#b.}#g#h0TQ/SQ#`Q!Q![/Y#g#h+uQ/]R!Q![/Y#a#b/f#g#h/lQ/iP#g#h+uQ/qP#`Q!Q![/tQ/wQ!Q![/t#a#b/}Q0QP#g#h+uQ0YP#`Q!Q![0]Q0`Q!Q![0]#a#b0fQ0iP#g#h+uQ0qQ#`Q!Q![0w#g#h+uQ0zR!Q![0w#a#b1T#g#h1ZQ1WP#g#h+uQ1`P#`Q!Q![1cQ1fQ!Q![1c#a#b1lQ1oP#g#h+uQ1wP#`Q!Q![1zQ1}Q!Q![1z#a#b2TQ2WP#g#h+uQ2`P#`Q!Q![2cQ2fT!Q![2c#W#X2u#[#]7O#a#b9R#g#h:XQ2zP#`Q!Q![2}Q3QS!Q![2}#[#]3^#a#b5a#g#h6gQ3cP#`Q!Q![3fQ3iR!Q![3f#a#b3r#g#h4xQ3wQ#`Q!Q![3}#g#h+uQ4QR!Q![3}#a#b4Z#g#h4aQ4^P#g#h+uQ4fP#`Q!Q![4iQ4lQ!Q![4i#a#b4rQ4uP#g#h+uQ4}P#`Q!Q![5QQ5TQ!Q![5Q#a#b5ZQ5^P#g#h+uQ5fQ#`Q!Q![5l#g#h+uQ5oR!Q![5l#a#b5x#g#h6OQ5{P#g#h+uQ6TP#`Q!Q![6WQ6ZQ!Q![6W#a#b6aQ6dP#g#h+uQ6lP#`Q!Q![6oQ6rQ!Q![6o#a#b6xQ6{P#g#h+uQ7TP#`Q!Q![7WQ7ZR!Q![7W#a#b7d#g#h8jQ7iQ#`Q!Q![7o#g#h+uQ7rR!Q![7o#a#b7{#g#h8RQ8OP#g#h+uQ8WP#`Q!Q![8ZQ8^Q!Q![8Z#a#b8dQ8gP#g#h+uQ8oP#`Q!Q![8rQ8uQ!Q![8r#a#b8{Q9OP#g#h+uQ9WQ#`Q!Q![9^#g#h+uQ9aR!Q![9^#a#b9j#g#h9pQ9mP#g#h+uQ9uP#`Q!Q![9xQ9{Q!Q![9x#a#b:RQ:UP#g#h+uQ:^P#`Q!Q![:aQ:dQ!Q![:a#a#b:jQ:mP#g#h+uQ:uP#`Q!Q![:xQ:{U!Q![:x#W#X;_#[#]?h#a#bAk#g#hBq#k#lCYQ;dP#`Q!Q![;gQ;jS!Q![;g#[#];v#a#b=y#g#h?PQ;{P#`Q!Q![<OQ<RR!Q![<O#a#b<[#g#h=bQ<aQ#`Q!Q![<g#g#h+uQ<jR!Q![<g#a#b<s#g#h<yQ<vP#g#h+uQ=OP#`Q!Q![=RQ=UQ!Q![=R#a#b=[Q=_P#g#h+uQ=gP#`Q!Q![=jQ=mQ!Q![=j#a#b=sQ=vP#g#h+uQ>OQ#`Q!Q![>U#g#h+uQ>XR!Q![>U#a#b>b#g#h>hQ>eP#g#h+uQ>mP#`Q!Q![>pQ>sQ!Q![>p#a#b>yQ>|P#g#h+uQ?UP#`Q!Q![?XQ?[Q!Q![?X#a#b?bQ?eP#g#h+uQ?mP#`Q!Q![?pQ?sR!Q![?p#a#b?|#g#hASQ@RQ#`Q!Q![@X#g#h+uQ@[R!Q![@X#a#b@e#g#h@kQ@hP#g#h+uQ@pP#`Q!Q![@sQ@vQ!Q![@s#a#b@|QAPP#g#h+uQAXP#`Q!Q![A[QA_Q!Q![A[#a#bAeQAhP#g#h+uQApQ#`Q!Q![Av#g#h+uQAyR!Q![Av#a#bBS#g#hBYQBVP#g#h+uQB_P#`Q!Q![BbQBeQ!Q![Bb#a#bBkQBnP#g#h+uQBvP#`Q!Q![ByQB|Q!Q![By#a#bCSQCVP#g#h+uQC_P#`Q!Q![CbQCeT!Q![Cb#W#XCt#[#]G}#a#bJQ#g#hKWQCyP#`Q!Q![C|QDPS!Q![C|#[#]D]#a#bF`#g#hGfQDbP#`Q!Q![DeQDhR!Q![De#a#bDq#g#hEwQDvQ#`Q!Q![D|#g#h+uQEPR!Q![D|#a#bEY#g#hE`QE]P#g#h+uQEeP#`Q!Q![EhQEkQ!Q![Eh#a#bEqQEtP#g#h+uQE|P#`Q!Q![FPQFSQ!Q![FP#a#bFYQF]P#g#h+uQFeQ#`Q!Q![Fk#g#h+uQFnR!Q![Fk#a#bFw#g#hF}QFzP#g#h+uQGSP#`Q!Q![GVQGYQ!Q![GV#a#bG`QGcP#g#h+uQGkP#`Q!Q![GnQGqQ!Q![Gn#a#bGwQGzP#g#h+uQHSP#`Q!Q![HVQHYR!Q![HV#a#bHc#g#hIiQHhQ#`Q!Q![Hn#g#h+uQHqR!Q![Hn#a#bHz#g#hIQQH}P#g#h+uQIVP#`Q!Q![IYQI]Q!Q![IY#a#bIcQIfP#g#h+uQInP#`Q!Q![IqQItQ!Q![Iq#a#bIzQI}P#g#h+uQJVQ#`Q!Q![J]#g#h+uQJ`R!Q![J]#a#bJi#g#hJoQJlP#g#h+uQJtP#`Q!Q![JwQJzQ!Q![Jw#a#bKQQKTP#g#h+uQK]P#`Q!Q![K`QKcQ!Q![K`#a#bKiQKlP#g#h+uPKrR!Q![K{!c!iK{#T#ZK{PLQR%WP!Q![K{!c!iK{#T#ZK{VLbT%XS!YR!Q![Lq![!]Lq!c!}Lq#R#SLq#T#oLqRLvT!YR!Q![Lq![!]Lq!c!}Lq#R#SLq#T#oLq~M[P!T~!_!`M_~MdO!S~~MiQ#nP!_!`Mo#r#sMtQMtO!PQ~MyO#o~~NOP!R~!_!`NR~NWO!Q~~N]O#r~VNdT!YRsS!Q![N]![!]Lq!c!}N]#R#SN]#T#oN]~NxO%S~~N}O%T~~! SOw~~! VRO#S! S#S#T%]#T~! S~! eO%Y~~! jO%Z~\",\n  tokenizers: [0, 1, 2],\n  topRules: {\"PromQL\":[0,27],\"MetricName\":[1,128]},\n  specialized: [{term: 56, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 56, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 56, get: value => spec_Identifier[value] || -1}],\n  tokenPrec: 0\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst \n  inf$1 = 130,\n  nan$1 = 131,\n  Bool$1 = 1,\n  Ignoring$1 = 2,\n  On$1 = 3,\n  GroupLeft$1 = 4,\n  GroupRight$1 = 5,\n  Offset$1 = 6,\n  Avg$1 = 7,\n  Bottomk$1 = 8,\n  Count$1 = 9,\n  CountValues$1 = 10,\n  Group$1 = 11,\n  Max$1 = 12,\n  Min$1 = 13,\n  Quantile$1 = 14,\n  Stddev$1 = 15,\n  Stdvar$1 = 16,\n  Sum$1 = 17,\n  Topk$1 = 18,\n  By$1 = 19,\n  Without$1 = 20,\n  And$1 = 21,\n  Or$1 = 22,\n  Unless$1 = 23,\n  Start$1 = 24,\n  End$1 = 25,\n  LineComment = 26,\n  PromQL = 27,\n  Expr = 28,\n  AggregateExpr = 29,\n  AggregateOp = 30,\n  AggregateModifier = 31,\n  GroupingLabels = 32,\n  GroupingLabelList = 33,\n  GroupingLabel = 34,\n  LabelName = 35,\n  FunctionCallBody = 36,\n  FunctionCallArgs = 37,\n  BinaryExpr = 38,\n  Pow = 39,\n  BinModifiers = 40,\n  OnOrIgnoring = 41,\n  Mul = 42,\n  Div = 43,\n  Mod = 44,\n  Add = 45,\n  Sub = 46,\n  Eql = 47,\n  Gte = 48,\n  Gtr = 49,\n  Lte = 50,\n  Lss = 51,\n  Neq = 52,\n  FunctionCall = 53,\n  FunctionIdentifier = 54,\n  AbsentOverTime = 55,\n  Identifier = 56,\n  Absent = 57,\n  Abs = 58,\n  AvgOverTime = 59,\n  Ceil = 60,\n  Changes = 61,\n  Clamp = 62,\n  ClampMax = 63,\n  ClampMin = 64,\n  CountOverTime = 65,\n  DaysInMonth = 66,\n  DayOfMonth = 67,\n  DayOfWeek = 68,\n  Delta = 69,\n  Deriv = 70,\n  Exp = 71,\n  Floor = 72,\n  HistogramQuantile = 73,\n  HoltWinters = 74,\n  Hour = 75,\n  Idelta = 76,\n  Increase = 77,\n  Irate = 78,\n  LabelReplace = 79,\n  LabelJoin = 80,\n  LastOverTime = 81,\n  Ln = 82,\n  Log10 = 83,\n  Log2 = 84,\n  MaxOverTime = 85,\n  MinOverTime = 86,\n  Minute = 87,\n  Month = 88,\n  PredictLinear = 89,\n  PresentOverTime = 90,\n  QuantileOverTime = 91,\n  Rate = 92,\n  Resets = 93,\n  Round = 94,\n  Scalar = 95,\n  Sgn = 96,\n  Sort = 97,\n  SortDesc = 98,\n  Sqrt = 99,\n  StddevOverTime = 100,\n  StdvarOverTime = 101,\n  SumOverTime = 102,\n  Timestamp = 103,\n  Time = 104,\n  Vector = 105,\n  Year = 106,\n  MatrixSelector = 107,\n  Duration = 108,\n  NumberLiteral = 109,\n  OffsetExpr = 110,\n  ParenExpr = 111,\n  StringLiteral = 112,\n  SubqueryExpr = 113,\n  UnaryExpr = 114,\n  UnaryOp = 115,\n  VectorSelector = 116,\n  MetricIdentifier = 117,\n  LabelMatchers = 118,\n  LabelMatchList = 119,\n  LabelMatcher = 120,\n  MatchOp = 121,\n  EqlSingle = 122,\n  EqlRegex = 123,\n  NeqRegex = 124,\n  StepInvariantExpr = 125,\n  At = 126,\n  AtModifierPreprocessors = 127,\n  MetricName = 128;\n\nexport { Abs, Absent, AbsentOverTime, Add, AggregateExpr, AggregateModifier, AggregateOp, And$1 as And, At, AtModifierPreprocessors, Avg$1 as Avg, AvgOverTime, BinModifiers, BinaryExpr, Bool$1 as Bool, Bottomk$1 as Bottomk, By$1 as By, Ceil, Changes, Clamp, ClampMax, ClampMin, Count$1 as Count, CountOverTime, CountValues$1 as CountValues, DayOfMonth, DayOfWeek, DaysInMonth, Delta, Deriv, Div, Duration, End$1 as End, Eql, EqlRegex, EqlSingle, Exp, Expr, Floor, FunctionCall, FunctionCallArgs, FunctionCallBody, FunctionIdentifier, Group$1 as Group, GroupLeft$1 as GroupLeft, GroupRight$1 as GroupRight, GroupingLabel, GroupingLabelList, GroupingLabels, Gte, Gtr, HistogramQuantile, HoltWinters, Hour, Idelta, Identifier, Ignoring$1 as Ignoring, Increase, Irate, LabelJoin, LabelMatchList, LabelMatcher, LabelMatchers, LabelName, LabelReplace, LastOverTime, LineComment, Ln, Log10, Log2, Lss, Lte, MatchOp, MatrixSelector, Max$1 as Max, MaxOverTime, MetricIdentifier, MetricName, Min$1 as Min, MinOverTime, Minute, Mod, Month, Mul, Neq, NeqRegex, NumberLiteral, Offset$1 as Offset, OffsetExpr, On$1 as On, OnOrIgnoring, Or$1 as Or, ParenExpr, Pow, PredictLinear, PresentOverTime, PromQL, Quantile$1 as Quantile, QuantileOverTime, Rate, Resets, Round, Scalar, Sgn, Sort, SortDesc, Sqrt, Start$1 as Start, Stddev$1 as Stddev, StddevOverTime, Stdvar$1 as Stdvar, StdvarOverTime, StepInvariantExpr, StringLiteral, Sub, SubqueryExpr, Sum$1 as Sum, SumOverTime, Time, Timestamp, Topk$1 as Topk, UnaryExpr, UnaryOp, Unless$1 as Unless, Vector, VectorSelector, Without$1 as Without, Year, inf$1 as inf, nan$1 as nan, parser };\n","// this helper class is used to make typescript warn you when you forget\n// a case-block in a switch statement.\n// example code that triggers the typescript-error:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// typescript will show an error in this case,\n// when you add the missing `case 'C'` code,\n// the problem will be fixed.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super('should never happen');\n  }\n}\n","import { parser } from 'lezer-promql';\nimport type { Tree, SyntaxNode } from 'lezer-tree';\nimport { NeverCaseError } from './util';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeTypeName =\n  | '' // this is used as error-name\n  | 'AggregateExpr'\n  | 'AggregateModifier'\n  | 'FunctionCallBody'\n  | 'GroupingLabels'\n  | 'Identifier'\n  | 'LabelMatcher'\n  | 'LabelMatchers'\n  | 'LabelMatchList'\n  | 'LabelName'\n  | 'MetricIdentifier'\n  | 'PromQL'\n  | 'StringLiteral'\n  | 'VectorSelector'\n  | 'MatrixSelector'\n  | 'MatchOp'\n  | 'EqlSingle'\n  | 'Neq'\n  | 'EqlRegex'\n  | 'NeqRegex';\n\ntype Path = Array<[Direction, NodeTypeName]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  switch (direction) {\n    case 'parent':\n      return node.parent;\n    case 'firstChild':\n      return node.firstChild;\n    case 'lastChild':\n      return node.lastChild;\n    case 'nextSibling':\n      return node.nextSibling;\n    default:\n      throw new NeverCaseError(direction);\n  }\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedType] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.name !== expectedType) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parsePromQLStringLiteral(text: string): string {\n  // if it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // FIXME: support https://prometheus.io/docs/prometheus/latest/querying/basics/#string-literals\n  // FIXME: maybe check other promql code, if all is supported or not\n\n  // for now we do only some very simple un-escaping\n\n  // we start with double-quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  }\n\n  // then single-quote\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  }\n\n  // then backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error('FIXME: invalid string literal');\n}\n\ntype LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'IN_FUNCTION';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'IN_DURATION';\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      metricName?: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_GROUPING';\n      metricName: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      metricName?: string;\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    };\n\ntype Resolver = {\n  path: NodeTypeName[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: string[], cursorPath: string[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_NAME: NodeTypeName = ''; // this is used as error-name\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: ['LabelMatchers', 'VectorSelector'],\n    fun: resolveLabelKeysWithEquals,\n  },\n  {\n    path: ['PromQL'],\n    fun: resolveTopLevel,\n  },\n  {\n    path: ['FunctionCallBody'],\n    fun: resolveInFunction,\n  },\n  {\n    path: ['StringLiteral', 'LabelMatcher'],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, 'LabelMatcher'],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, 'MatrixSelector'],\n    fun: resolveDurations,\n  },\n  {\n    path: ['GroupingLabels'],\n    fun: resolveLabelsForGrouping,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['EqlSingle', '='],\n  ['EqlRegex', '=~'],\n  ['Neq', '!='],\n  ['NeqRegex', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  const opChild = opNode.firstChild;\n  if (opChild === null) {\n    return null;\n  }\n\n  return LABEL_OP_MAP.get(opChild.name) ?? null;\n}\n\nfunction getLabel(labelMatcherNode: SyntaxNode, text: string): Label | null {\n  if (labelMatcherNode.type.name !== 'LabelMatcher') {\n    return null;\n  }\n\n  const nameNode = walk(labelMatcherNode, [['firstChild', 'LabelName']]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = walk(nameNode, [['nextSibling', 'MatchOp']]);\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(labelMatcherNode, [['lastChild', 'StringLiteral']]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parsePromQLStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\nfunction getLabels(labelMatchersNode: SyntaxNode, text: string): Label[] {\n  if (labelMatchersNode.type.name !== 'LabelMatchers') {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(labelMatchersNode, [['firstChild', 'LabelMatchList']]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', 'LabelMatcher']]);\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n    if (label !== null) {\n      labels.push(label);\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', 'LabelMatchList']]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction getNodeChildren(node: SyntaxNode): SyntaxNode[] {\n  let child: SyntaxNode | null = node.firstChild;\n  const children: SyntaxNode[] = [];\n  while (child !== null) {\n    children.push(child);\n    child = child.nextSibling;\n  }\n  return children;\n}\n\nfunction getNodeInSubtree(node: SyntaxNode, typeName: NodeTypeName): SyntaxNode | null {\n  // first we try the current node\n  if (node.type.name === typeName) {\n    return node;\n  }\n\n  // then we try the children\n  const children = getNodeChildren(node);\n  for (const child of children) {\n    const n = getNodeInSubtree(child, typeName);\n    if (n !== null) {\n      return n;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [\n    ['parent', 'AggregateModifier'],\n    ['parent', 'AggregateExpr'],\n  ]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('FunctionCallBody');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const metricIdNode = getNodeInSubtree(bodyNode, 'MetricIdentifier');\n  if (metricIdNode === null) {\n    return null;\n  }\n\n  const idNode = walk(metricIdNode, [['firstChild', 'Identifier']]);\n  if (idNode === null) {\n    return null;\n  }\n\n  const metricName = getNodeText(idNode, text);\n  return {\n    type: 'IN_GROUPING',\n    metricName,\n    otherLabels: [],\n  };\n}\n\nfunction resolveLabelMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here in two situation. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', 'LabelMatcher']]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', 'LabelName']]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of LabelMatcher,\n  // there can be one or many `LabelMatchList` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', 'LabelMatchList']]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes\n  // as long as they are LabelMatchList.\n  // as soon as we reawch LabelMatchers, we stop\n  let labelMatchersNode: SyntaxNode | null = null;\n  while (labelMatchersNode === null) {\n    const p = listNode.parent;\n    if (p === null) {\n      return null;\n    }\n\n    const { name } = p.type;\n\n    switch (name) {\n      case 'LabelMatchList':\n        //we keep looping\n        listNode = p;\n        continue;\n      case 'LabelMatchers':\n        // we reached the end, we can stop the loop\n        labelMatchersNode = p;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(labelMatchersNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  const metricNameNode = walk(labelMatchersNode, [\n    ['parent', 'VectorSelector'],\n    ['firstChild', 'MetricIdentifier'],\n    ['firstChild', 'Identifier'],\n  ]);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name\n    return {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n      labelName,\n      betweenQuotes: inStringNode,\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    metricName,\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'AT_ROOT',\n  };\n}\n\nfunction resolveInFunction(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_FUNCTION',\n  };\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_DURATION',\n  };\n}\n\nfunction subTreeHasError(node: SyntaxNode): boolean {\n  return getNodeInSubtree(node, ERROR_NODE_NAME) !== null;\n}\n\nfunction resolveLabelKeysWithEquals(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `something{^}`\n\n  // there are some false positives that can end up in this situation, that we want\n  // to eliminate:\n  // `something{a~^}` (if this subtree contains any error-node, we stop)\n  if (subTreeHasError(node)) {\n    return null;\n  }\n\n  // next false positive:\n  // `something{a=\"1\"^}`\n  const child = walk(node, [['firstChild', 'LabelMatchList']]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const metricNameNode = walk(node, [\n    ['parent', 'VectorSelector'],\n    ['firstChild', 'MetricIdentifier'],\n    ['firstChild', 'Identifier'],\n  ]);\n\n  const otherLabels = getLabels(node, text);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name.\n    return {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    metricName,\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, pos: number): SyntaxNode | null {\n  const cur = tree.cursor(pos);\n  while (true) {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n\n    if (!cur.next()) {\n      break;\n    }\n  }\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special-case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  /*\n\tPromQL\nExpr\nVectorSelector\nLabelMatchers\n*/\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error-nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error-node at the cursor-position\n  const maybeErrorNode = getErrorNode(tree, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor : tree.cursor(pos);\n  const currentNode = cur.node;\n\n  const names = [cur.name];\n  while (cur.parent()) {\n    names.push(cur.name);\n  }\n\n  for (let resolver of RESOLVERS) {\n    // i do not use a foreach because i want to stop as soon\n    // as i find something\n    if (isPathMatch(resolver.path, names)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n","import type { Situation, Label } from './situation';\nimport { NeverCaseError } from './util';\n// FIXME: we should not load this from the \"outside\", but we cannot do that while we have the \"old\" query-field too\nimport { FUNCTIONS } from '../../../promql';\nimport { escapeLabelValueInExactSelector } from '../../../language_utils';\n\nexport type CompletionType = 'HISTORY' | 'FUNCTION' | 'METRIC_NAME' | 'DURATION' | 'LABEL_NAME' | 'LABEL_VALUE';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n};\n\ntype Metric = {\n  name: string;\n  help: string;\n  type: string;\n};\n\nexport type DataProvider = {\n  getHistory: () => Promise<string[]>;\n  getAllMetricNames: () => Promise<Metric[]>;\n  getAllLabelNames: () => Promise<string[]>;\n  getLabelValues: (labelName: string) => Promise<string[]>;\n  getSeries: (selector: string) => Promise<Record<string, string[]>>;\n};\n\n// we order items like: history, functions, metrics\n\nasync function getAllMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metrics = await dataProvider.getAllMetricNames();\n  return metrics.map((metric) => ({\n    type: 'METRIC_NAME',\n    label: metric.name,\n    insertText: metric.name,\n    detail: `${metric.name} : ${metric.type}`,\n    documentation: metric.help,\n  }));\n}\n\nconst FUNCTION_COMPLETIONS: Completion[] = FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: f.insertText ?? '', // i don't know what to do when this is nullish. it should not be.\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nasync function getAllFunctionsAndMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metricNames = await getAllMetricNamesCompletions(dataProvider);\n  return [...FUNCTION_COMPLETIONS, ...metricNames];\n}\n\nconst DURATION_COMPLETIONS: Completion[] = [\n  '$__interval',\n  '$__range',\n  '$__rate_interval',\n  '1m',\n  '5m',\n  '10m',\n  '30m',\n  '1h',\n  '1d',\n].map((text) => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text,\n}));\n\nasync function getAllHistoryCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  // function getAllHistoryCompletions(queryHistory: PromHistoryItem[]): Completion[] {\n  // NOTE: the typescript types are wrong. historyItem.query.expr can be undefined\n  const allHistory = await dataProvider.getHistory();\n  // FIXME: find a better history-limit\n  return allHistory.slice(0, 10).map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nfunction makeSelector(metricName: string | undefined, labels: Label[]): string {\n  const allLabels = [...labels];\n\n  // we transform the metricName to a label, if it exists\n  if (metricName !== undefined) {\n    allLabels.push({ name: '__name__', value: metricName, op: '=' });\n  }\n\n  const allLabelTexts = allLabels.map(\n    (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n  );\n\n  return `{${allLabelTexts.join(',')}}`;\n}\n\nasync function getLabelNames(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getAllLabelNames();\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    const possibleLabelNames = Object.keys(data); // all names from prometheus\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((l) => !usedLabelNames.has(l));\n  }\n}\n\nasync function getLabelNamesForCompletions(\n  metric: string | undefined,\n  suffix: string,\n  triggerOnInsert: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const labelNames = await getLabelNames(metric, otherLabels, dataProvider);\n  return labelNames.map((text) => ({\n    type: 'LABEL_NAME',\n    label: text,\n    insertText: `${text}${suffix}`,\n    triggerOnInsert,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '=', true, otherLabels, dataProvider);\n}\nasync function getLabelNamesForByCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '', false, otherLabels, dataProvider);\n}\n\nasync function getLabelValues(\n  metric: string | undefined,\n  labelName: string,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getLabelValues(labelName);\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    return data[labelName] ?? [];\n  }\n}\n\nasync function getLabelValuesForMetricCompletions(\n  metric: string | undefined,\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const values = await getLabelValues(metric, labelName, otherLabels, dataProvider);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? text : `\"${text}\"`, // FIXME: escaping strange characters?\n  }));\n}\n\nexport async function getCompletions(situation: Situation, dataProvider: DataProvider): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'IN_DURATION':\n      return DURATION_COMPLETIONS;\n    case 'IN_FUNCTION':\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    case 'AT_ROOT': {\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    }\n    case 'EMPTY': {\n      const metricNames = await getAllMetricNamesCompletions(dataProvider);\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [...historyCompletions, ...FUNCTION_COMPLETIONS, ...metricNames];\n    }\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_GROUPING':\n      return getLabelNamesForByCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.metricName,\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { getSituation } from './situation';\nimport { getCompletions, DataProvider, CompletionType } from './completions';\nimport { NeverCaseError } from './util';\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'METRIC_NAME':\n      return monaco.languages.CompletionItemKind.Constructor;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: DataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by-default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"'],\n    provideCompletionItems,\n  };\n}\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface-docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface-docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices | null = null;\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // only have one instance of this for every query editor\n  if (overrideServices === null) {\n    overrideServices = {\n      storageService: makeStorageService(),\n    };\n  }\n\n  return overrideServices;\n}\n","import React, { useRef, useEffect } from 'react';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes } from '@grafana/ui';\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { css } from '@emotion/css';\nimport { useLatest } from 'react-use';\nimport { promLanguageDefinition } from 'monaco-promql';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider';\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst PROMQL_LANG_ID = promLanguageDefinition.id;\n\n// we must only run the promql-setup code once\nlet PROMQL_SETUP_STARTED = false;\n\nfunction ensurePromQL(monaco: Monaco) {\n  if (PROMQL_SETUP_STARTED === false) {\n    PROMQL_SETUP_STARTED = true;\n    const { aliases, extensions, mimetypes, loader } = promLanguageDefinition;\n    monaco.languages.register({ id: PROMQL_LANG_ID, aliases, extensions, mimetypes });\n\n    loader().then((mod) => {\n      monaco.languages.setMonarchTokensProvider(PROMQL_LANG_ID, mod.language);\n      monaco.languages.setLanguageConfiguration(PROMQL_LANG_ID, mod.languageConfiguration);\n    });\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.borderRadius()};\n      border: 1px solid ${theme.components.input.borderColor};\n    `,\n  };\n};\n\nconst MonacoQueryField = (props: Props) => {\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { languageProvider, history, onBlur, onRunQuery, initialValue } = props;\n\n  const lpRef = useLatest(languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n\n  const autocompleteDisposeFun = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteDisposeFun.current?.();\n    };\n  }, []);\n\n  return (\n    <div\n      aria-label={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language=\"promql\"\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensurePromQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            onBlurRef.current(editor.getValue());\n          });\n\n          // we construct a DataProvider object\n          const getSeries = (selector: string) => lpRef.current.getSeries(selector);\n\n          const getHistory = () =>\n            Promise.resolve(historyRef.current.map((h) => h.query.expr).filter((expr) => expr !== undefined));\n\n          const getAllMetricNames = () => {\n            const { metrics, metricsMetadata } = lpRef.current;\n            const result = metrics.map((m) => {\n              const metaItem = metricsMetadata?.[m];\n              return {\n                name: m,\n                help: metaItem?.help ?? '',\n                type: metaItem?.type ?? '',\n              };\n            });\n\n            return Promise.resolve(result);\n          };\n\n          const getAllLabelNames = () => Promise.resolve(lpRef.current.getLabelKeys());\n\n          const getLabelValues = (labelName: string) => lpRef.current.getLabelValues(labelName);\n\n          const dataProvider = { getSeries, getHistory, getAllMetricNames, getAllLabelNames, getLabelValues };\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registerd to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(\n            PROMQL_LANG_ID,\n            filteringCompletionProvider\n          );\n\n          autocompleteDisposeFun.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const updateElementHeight = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              containerDiv.style.width = '100%';\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(updateElementHeight);\n          updateElementHeight();\n\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {\n            onRunQueryRef.current(editor.getValue());\n          });\n        }}\n      />\n    </div>\n  );\n};\n\n// we will lazy-load this module using React.lazy,\n// and that only supports default-exports,\n// so we have to default-export this, even if\n// it is agains the style-guidelines.\n\nexport default MonacoQueryField;\n"],"names":["value","ref","useRef","current","promLanguageDefinition","id","extensions","aliases","mimetypes","loader","DefaultBufferLength","nextPropID","CachedNode","WeakMap","NodeProp","constructor","deserialize","this","Error","static","str","Number","set","propObj","add","match","NodeType","type","result","undefined","closedBy","split","openedBy","group","noProps","Object","create","name","props","flags","spec","length","top","skipped","error","src","Array","isArray","prop","isTop","isSkipped","isError","isAnonymous","is","indexOf","map","direct","node","groups","i","found","none","NodeSet","types","RangeError","extend","newTypes","newProps","source","assign","push","Tree","children","positions","toString","c","join","test","JSON","stringify","cursor","pos","side","scope","get","topNode","TreeCursor","moveTo","_tree","fullCursor","TreeNode","resolve","iterate","enter","leave","from","to","mustLeave","firstChild","nextSibling","parent","balance","maxBufferLength","BalanceBranchFactor","balanceRange","data","_a","buffer","nodeSet","topID","reused","minRepeatType","FlatBufferCursor","contextHash","takeNode","parentStart","minPos","inRepeat","start","end","size","startPos","next","findBufferSize","Uint16Array","skip","endPos","index","copyToBuffer","TreeBuffer","localChildren","localPositions","localInRepeat","reverse","withHash","maxSize","fork","minStart","scan","nodeSize","localSkipped","nodeStart","bufferStart","startIndex","buildTree","tree","hash","empty","childString","endIndex","findChild","dir","after","pick","_parent","nextChild","full","e","BufferNode","BufferContext","hasChild","inner","lastChild","childAfter","childBefore","nextSignificantParent","val","prevSibling","getChild","before","r","getChildren","cur","context","child","externalSibling","stack","bufferNode","yieldNode","n","unshift","yieldBuf","yield","pop","sibling","d","atLastNode","move","prev","cache","depth","some","ch","outerType","innerType","maxChild","Math","max","ceil","groupFrom","groupStart","only","j","containsType","nodes","elt","stringInput","input","StringInput","string","charCodeAt","lineAfter","slice","min","read","clip","at","Stack","p","state","reducePos","score","bufferBase","curContext","filter","_","concat","cx","parser","StackContext","pushState","reduce","action","dPrec","dynamicPrecedence","minRepeatTerm","storeNode","getGoto","reduceContext","base","count","stateFlag","baseStateID","term","isReduce","shift","nextEnd","nextState","maxNode","shiftContext","apply","useNode","updateContext","tracker","reuse","off","recoverByDelete","isNode","canShift","sim","SimulatedStack","stateSlot","hasAction","ruleStart","force","startOf","frame","recoverByInsert","nextStates","best","s","v","forceReduce","validAction","forceAll","deadEnd","restart","sameState","other","dialectEnabled","dialectID","dialect","emitContext","strict","last","newCx","Recover","rest","offset","goto","StackBufferCursor","maybeNext","Token","accept","TokenGroup","token","groupMask","accEnd","allows","overrides","low","high","mid","readToken","prototype","contextual","fallback","decodeArray","Type","array","out","stop","digit","verbose","process","env","LOG","stackIDs","cutAt","FragmentCursor","fragments","fragment","safeFrom","safeTo","trees","nextFragment","fr","openStart","openEnd","nextStart","nodeAt","CachedToken","super","arguments","extended","mask","clear","dummyToken","TokenCache","tokens","mainToken","actions","tokenizers","getActions","actionIndex","main","tokenizer","updateCachedToken","addActions","eofTerm","specialized","specializers","putAction","pair","Rec","Parse","recovering","nextStackID","nested","nestEnd","nestWrap","topTerm","stacks","advance","finishNested","stopped","stoppedTokens","maybeNest","newStacks","nest","checkNest","advanceStack","tok","startNested","finished","findFinished","stackToTree","console","log","getName","SyntaxError","runRecovery","maxRemaining","sort","a","b","outer","splice","stackID","strictCx","cxHash","cached","defaultReduce","localStack","advanceFully","pushStackDedup","restarted","tokenEnd","done","forceBase","insert","forceFinish","build","bufferLength","info","findNested","scanForNestEnd","filterEnd","wrapType","startParse","endToken","placeholder","String","fromCodePoint","Dialect","disabled","Parser","cachedDialect","version","tokenArray","tokenData","nodeNames","repeatNodeCount","nodeProps","setProp","nodeID","propSpec","states","Uint32Array","stateData","topTerms","keys","topRules","define","skippedNodes","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","parse","loose","table","groupTag","target","terminal","slot","flag","iPrev","findOffset","configure","config","copy","t","find","obj","hasOwnProperty","call","hasNested","prec","values","part","Uint8Array","keywordTokens","inf","nan","bool","ignoring","on","group_left","group_right","contextualKeywordTokens","avg","bottomk","count_values","quantile","stddev","stdvar","sum","topk","by","without","and","or","unless","spec_Identifier","__proto__","absent_over_time","absent","abs","avg_over_time","changes","clamp","clamp_max","clamp_min","count_over_time","days_in_month","day_of_month","day_of_week","delta","deriv","exp","floor","histogram_quantile","holt_winters","hour","idelta","increase","irate","label_replace","label_join","last_over_time","ln","log10","log2","max_over_time","min_over_time","minute","month","predict_linear","present_over_time","quantile_over_time","rate","resets","round","scalar","sgn","sort_desc","sqrt","stddev_over_time","stdvar_over_time","sum_over_time","timestamp","time","vector","year","toLowerCase","specializeIdentifier","extendIdentifier","NeverCaseError","direction","walk","path","expectedType","getNodeText","text","isPathMatch","resolverPath","cursorPath","every","item","ERROR_NODE_NAME","RESOLVERS","fun","getNodeInSubtree","subTreeHasError","includes","metricNameNode","otherLabels","getLabels","metricName","resolveLabelMatcher","aggrExpNode","bodyNode","metricIdNode","idNode","LABEL_OP_MAP","Map","getLabel","labelMatcherNode","nameNode","opNode","op","opChild","getLabelOp","valueNode","inside","startsWith","endsWith","replace","parsePromQLStringLiteral","labelMatchersNode","listNode","labels","matcherNode","label","typeName","getNodeChildren","inStringNode","labelNameNode","labelName","firstListNode","betweenQuotes","async","getAllMetricNamesCompletions","dataProvider","getAllMetricNames","metric","insertText","detail","documentation","help","FUNCTION_COMPLETIONS","FUNCTIONS","f","getAllFunctionsAndMetricNamesCompletions","metricNames","DURATION_COMPLETIONS","makeSelector","allLabels","escapeLabelValueInExactSelector","getLabelNamesForCompletions","suffix","triggerOnInsert","labelNames","getAllLabelNames","selector","getSeries","possibleLabelNames","usedLabelNames","Set","l","has","getLabelNames","getLabelValuesForMetricCompletions","getLabelValues","getCompletions","situation","historyCompletions","getHistory","expr","getAllHistoryCompletions","getLabelNamesForSelectorCompletions","getLabelNamesForByCompletions","getMonacoCompletionItemKind","monaco","languages","CompletionItemKind","Unit","Variable","Snippet","Enum","EnumMember","Constructor","getCompletionProvider","triggerCharacters","provideCompletionItems","model","position","word","getWordAtPosition","range","Range","lift","startLineNumber","lineNumber","endLineNumber","startColumn","endColumn","fromPositions","positionClone","column","getOffsetAt","maybeErrorNode","getErrorNode","currentNode","names","resolver","getSituation","getValue","Promise","then","items","maxIndexDigits","suggestions","kind","sortText","padStart","command","title","makeStorageService","strings","onDidChangeValue","onDidChangeTarget","onWillSaveState","key","fallbackValue","getBoolean","getNumber","parseInt","store","delete","remove","logStorage","migrate","isNew","flush","reason","overrideServices","options","codeLens","contextmenu","fixedOverflowWidgets","folding","fontSize","lineDecorationsWidth","lineNumbers","minimap","enabled","overviewRulerBorder","overviewRulerLanes","padding","bottom","renderLineHighlight","scrollbar","vertical","verticalScrollbarSize","horizontal","horizontalScrollbarSize","scrollBeyondLastLine","suggest","showWords","suggestFontSize","wordWrap","PROMQL_LANG_ID","PROMQL_SETUP_STARTED","overrideServicesRef","storageService","containerRef","languageProvider","history","onBlur","onRunQuery","initialValue","lpRef","useLatest","historyRef","onRunQueryRef","onBlurRef","autocompleteDisposeFun","styles","theme","container","css","shape","borderRadius","components","borderColor","getStyles","useTheme2","useEffect","selectors","className","ReactMonacoEditor","language","beforeMount","register","mod","setMonarchTokensProvider","setLanguageConfiguration","languageConfiguration","ensurePromQL","onMount","editor","onDidBlurEditorWidget","completionProvider","h","query","metrics","metricsMetadata","m","metaItem","getLabelKeys","filteringCompletionProvider","getModel","dispose","registerCompletionItemProvider","updateElementHeight","containerDiv","pixelHeight","getContentHeight","style","height","width","pixelWidth","clientWidth","layout","onDidContentSizeChange","addCommand","KeyMod","Shift","KeyCode","Enter"],"sourceRoot":""}