{"version":3,"file":"AlertingRedirectToRule.1f65f885c5a67f13d9d6.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/RedirectToRuleViewer.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-viewer/RuleViewerLayout.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRule.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts"],"sourcesContent":["import React from 'react';\nimport { Redirect } from 'react-router-dom';\nimport { css } from '@emotion/css';\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Alert, Card, Icon, LoadingPlaceholder, useStyles2, withErrorBoundary } from '@grafana/ui';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\nimport { useCombinedRulesMatching } from './hooks/useCombinedRule';\nimport { createViewLink } from './utils/misc';\nimport { getRulesSourceByName } from './utils/datasource';\nimport { RuleViewerLayout } from './components/rule-viewer/RuleViewerLayout';\nimport { AlertLabels } from './components/AlertLabels';\n\ntype RedirectToRuleViewerProps = GrafanaRouteComponentProps<{ name?: string; sourceName?: string }>;\nconst pageTitle = 'Alerting / Find rule';\n\nexport function RedirectToRuleViewer(props: RedirectToRuleViewerProps): JSX.Element | null {\n  const { name, sourceName } = props.match.params;\n  const styles = useStyles2(getStyles);\n  const { error, loading, result: rules, dispatched } = useCombinedRulesMatching(name, sourceName);\n\n  if (error) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title={`Failed to load rules from ${sourceName}`}>\n          <details className={styles.errorMessage}>\n            {error.message}\n            <br />\n            {!!error?.stack && error.stack}\n          </details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (loading || !dispatched || !Array.isArray(rules)) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <LoadingPlaceholder text=\"Loading rule...\" />\n      </RuleViewerLayout>\n    );\n  }\n\n  if (!name || !sourceName) {\n    return <Redirect to=\"/notfound\" />;\n  }\n\n  const rulesSource = getRulesSourceByName(sourceName);\n\n  if (!rulesSource) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title=\"Could not view rule\">\n          <details className={styles.errorMessage}>{`Could not find data source with name: ${sourceName}.`}</details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (rules.length === 1) {\n    const [rule] = rules;\n    return <Redirect to={createViewLink(rulesSource, rule, '/alerting/list')} />;\n  }\n\n  return (\n    <RuleViewerLayout title={pageTitle}>\n      <div>\n        Several rules in <span className={styles.param}>{sourceName}</span> matched the name{' '}\n        <span className={styles.param}>{name}</span>, please select the rule you want to view.\n      </div>\n      <div className={styles.rules}>\n        {rules.map((rule, index) => {\n          return (\n            <Card\n              key={`${rule.name}-${index}`}\n              heading={rule.name}\n              href={createViewLink(rulesSource, rule, '/alerting/list')}\n            >\n              <Card.Meta separator={''}>\n                <Icon name=\"folder\" />\n                <span className={styles.namespace}>{`${rule.namespace.name} / ${rule.group.name}`}</span>\n              </Card.Meta>\n              <Card.Tags>\n                <AlertLabels labels={rule.labels} />\n              </Card.Tags>\n            </Card>\n          );\n        })}\n      </div>\n    </RuleViewerLayout>\n  );\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    param: css`\n      font-style: italic;\n      color: ${theme.colors.text.secondary};\n    `,\n    rules: css`\n      margin-top: ${theme.spacing(2)};\n    `,\n    namespace: css`\n      margin-left: ${theme.spacing(1)};\n    `,\n    errorMessage: css`\n      white-space: pre-wrap;\n    `,\n  };\n}\n\nexport default withErrorBoundary(RedirectToRuleViewer, { style: 'page' });\n","import React from 'react';\nimport { css } from '@emotion/css';\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport { PageToolbar, useStyles2 } from '@grafana/ui';\nimport { Page } from 'app/core/components/Page/Page';\n\ntype Props = {\n  children: React.ReactNode | React.ReactNode[];\n  title: string;\n  wrapInContent?: boolean;\n};\n\nexport function RuleViewerLayout(props: Props): JSX.Element | null {\n  const { wrapInContent = true, children, title } = props;\n  const styles = useStyles2(getPageStyles);\n\n  return (\n    <Page>\n      <PageToolbar title={title} pageIcon=\"bell\" onGoBack={() => locationService.push('/alerting/list')} />\n      <div className={styles.content}>{wrapInContent ? <RuleViewerLayoutContent {...props} /> : children}</div>\n    </Page>\n  );\n}\n\ntype ContentProps = {\n  children: React.ReactNode | React.ReactNode[];\n  padding?: number;\n};\n\nexport function RuleViewerLayoutContent({ children, padding = 2 }: ContentProps): JSX.Element | null {\n  const styles = useStyles2(getContentStyles(padding));\n  return <div className={styles.wrapper}>{children}</div>;\n}\n\nconst getPageStyles = (theme: GrafanaTheme2) => {\n  return {\n    content: css`\n      margin: ${theme.spacing(0, 2, 2)};\n      max-width: ${theme.breakpoints.values.xxl}px;\n    `,\n  };\n};\n\nconst getContentStyles = (padding: number) => (theme: GrafanaTheme2) => {\n  return {\n    wrapper: css`\n      background: ${theme.colors.background.primary};\n      border: 1px solid ${theme.colors.border.weak};\n      border-radius: ${theme.shape.borderRadius()};\n      padding: ${theme.spacing(padding)};\n    `,\n  };\n};\n","import { useEffect, useMemo } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { CombinedRule, RuleIdentifier, RuleNamespace } from 'app/types/unified-alerting';\nimport { AsyncRequestMapSlice, AsyncRequestState, initialAsyncRequestState } from '../utils/redux';\nimport { useCombinedRuleNamespaces } from './useCombinedRuleNamespaces';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\nimport { fetchPromRulesAction, fetchRulerRulesAction } from '../state/actions';\nimport { RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\nimport * as ruleId from '../utils/rule-id';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\n\nexport function useCombinedRule(\n  identifier: RuleIdentifier | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rule = useMemo(() => {\n    if (!identifier || !ruleSourceName || combinedRules.length === 0) {\n      return;\n    }\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          const id = ruleId.fromCombinedRule(ruleSourceName, rule);\n\n          if (ruleId.equal(id, identifier)) {\n            return rule;\n          }\n        }\n      }\n    }\n\n    return;\n  }, [identifier, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rule,\n  };\n}\n\nexport function useCombinedRulesMatching(\n  ruleName: string | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule[]> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rules = useMemo(() => {\n    if (!ruleName || !ruleSourceName || combinedRules.length === 0) {\n      return [];\n    }\n\n    const rules: CombinedRule[] = [];\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          if (rule.name === ruleName) {\n            rules.push(rule);\n          }\n        }\n      }\n    }\n\n    return rules;\n  }, [ruleName, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rules,\n  };\n}\n\nfunction useCombinedRulesLoader(rulesSourceName: string | undefined): AsyncRequestState<void> {\n  const dispatch = useDispatch();\n  const promRuleRequests = useUnifiedAlertingSelector((state) => state.promRules);\n  const promRuleRequest = getRequestState(rulesSourceName, promRuleRequests);\n  const rulerRuleRequests = useUnifiedAlertingSelector((state) => state.rulerRules);\n  const rulerRuleRequest = getRequestState(rulesSourceName, rulerRuleRequests);\n\n  useEffect(() => {\n    if (!rulesSourceName) {\n      return;\n    }\n\n    dispatch(fetchPromRulesAction({ rulesSourceName }));\n    dispatch(fetchRulerRulesAction({ rulesSourceName }));\n  }, [dispatch, rulesSourceName]);\n\n  return {\n    loading: promRuleRequest.loading || rulerRuleRequest.loading,\n    error: promRuleRequest.error ?? isRulerNotSupportedResponse(rulerRuleRequest) ? undefined : rulerRuleRequest.error,\n    dispatched: promRuleRequest.dispatched && rulerRuleRequest.dispatched,\n  };\n}\n\nfunction getRequestState(\n  ruleSourceName: string | undefined,\n  slice: AsyncRequestMapSlice<RulerRulesConfigDTO | RuleNamespace[] | null>\n): AsyncRequestState<RulerRulesConfigDTO | RuleNamespace[] | null> {\n  if (!ruleSourceName) {\n    return initialAsyncRequestState;\n  }\n\n  const state = slice[ruleSourceName];\n\n  if (!state) {\n    return initialAsyncRequestState;\n  }\n\n  return state;\n}\n","import {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\nimport { useMemo, useRef } from 'react';\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n          if (isGrafanaRulesSource(rulesSource)) {\n            // merge all groups in case of grafana managed, essentially treating namespaces (folders) as gorups\n            result.forEach((namespace) => {\n              namespace.groups = [\n                {\n                  name: 'default',\n                  rules: namespace.groups.flatMap((g) => g.rules).sort((a, b) => a.name.localeCompare(b.name)),\n                },\n              ];\n            });\n          }\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[]): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  groups.forEach((group) => {\n    let combinedGroup = namespace.groups.find((g) => g.name === group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n    }\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedGroup!, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  group: CombinedRuleGroup,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return group!.rules.find((existingRule) => existingRule.name === rule.name);\n  }\n  return (\n    // try finding a rule that matches name, labels, annotations and query\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, true)\n    ) ??\n    // if that fails, try finding a rule that only matches name, labels and annotations.\n    // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, false)\n    )\n  );\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return (\n      JSON.stringify([\n        checkQuery ? hashQuery(combinedRule.query) : '',\n        combinedRule.labels,\n        combinedRule.annotations,\n      ]) ===\n      JSON.stringify([\n        checkQuery ? hashQuery(rule.query) : '',\n        rule.labels || {},\n        isAlertingRule(rule) ? rule.annotations || {} : {},\n      ])\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.substr(1, query.length - 2);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n"],"names":["pageTitle","RedirectToRuleViewer","props","name","sourceName","match","params","styles","useStyles2","getStyles","error","loading","result","rules","dispatched","useCombinedRulesMatching","title","Alert","className","errorMessage","message","stack","Array","isArray","LoadingPlaceholder","text","to","rulesSource","getRulesSourceByName","length","rule","createViewLink","param","map","index","Card","heading","href","separator","Icon","namespace","group","labels","theme","css","colors","secondary","spacing","withErrorBoundary","style","RuleViewerLayout","wrapInContent","children","getPageStyles","PageToolbar","pageIcon","onGoBack","locationService","content","RuleViewerLayoutContent","padding","getContentStyles","wrapper","breakpoints","values","xxl","background","primary","border","weak","shape","borderRadius","useCombinedRule","identifier","ruleSourceName","requestState","useCombinedRulesLoader","combinedRules","useCombinedRuleNamespaces","useMemo","groups","id","ruleId","ruleName","push","rulesSourceName","dispatch","useDispatch","promRuleRequests","useUnifiedAlertingSelector","state","promRules","promRuleRequest","getRequestState","rulerRuleRequests","rulerRules","rulerRuleRequest","useEffect","fetchPromRulesAction","fetchRulerRulesAction","isRulerNotSupportedResponse","undefined","slice","initialAsyncRequestState","promRulesResponses","rulerRulesResponses","cache","useRef","rulesSources","Error","getAllRulesSources","isCloudRulesSource","cached","current","namespaces","Object","entries","forEach","namespaceName","combinedGroup","interval","isAlertingRulerRule","alert","query","expr","annotations","rulerRule","isRecordingRulerRule","record","grafana_alert","rulerRuleToCombinedRule","addRulerGroupsToCombinedNamespace","find","g","existingRule","isGrafanaRulesSource","promRule","isCombinedRuleEqualToPromRule","getExistingRuleInGroup","isAlertingRule","promRuleToCombinedRule","addPromGroupsToCombinedNamespace","flatMap","sort","a","b","localeCompare","flat","combinedRule","checkQuery","JSON","stringify","hashQuery","substr","replace","split","join"],"sourceRoot":""}