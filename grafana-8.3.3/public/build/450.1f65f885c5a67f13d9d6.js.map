{"version":3,"file":"450.1f65f885c5a67f13d9d6.js","mappings":"8bAWA,MAAMA,EAAqB,CACzB,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QAGIC,EAA8B,GAEpC,IAAK,IAAIC,EAAI,EAAGA,EAAI,IAAKA,IACvBD,EAAqBC,GAClBA,GAAK,IAAMA,GAAK,IACX,KAANA,GACM,MAANA,GACM,MAANA,GACCA,GAAK,IAAMA,GAAK,IACX,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACCA,GAAK,IAAMA,GAAK,IAGrB,MAAMC,EAAsBF,EAErB,MAAMG,EAKXC,YAAYC,GAAiB,mEAC3BC,KAAKC,MAAQF,EACbC,K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","sources":["webpack://grafana/./public/app/plugins/datasource/graphite/lexer.ts","webpack://grafana/./public/app/plugins/datasource/graphite/parser.ts","webpack://grafana/./public/app/plugins/datasource/graphite/graphite_query.ts"],"sourcesContent":["import { bind } from 'lodash';\n\n// This is auto generated from the unicode tables.\n// The tables are at:\n// http://www.fileformat.info/info/unicode/category/Lu/list.htm\n// http://www.fileformat.info/info/unicode/category/Ll/list.htm\n// http://www.fileformat.info/info/unicode/category/Lt/list.htm\n// http://www.fileformat.info/info/unicode/category/Lm/list.htm\n// http://www.fileformat.info/info/unicode/category/Lo/list.htm\n// http://www.fileformat.info/info/unicode/category/Nl/list.htm\n\nconst unicodeLetterTable = [\n  170,\n  170,\n  181,\n  181,\n  186,\n  186,\n  192,\n  214,\n  216,\n  246,\n  248,\n  705,\n  710,\n  721,\n  736,\n  740,\n  748,\n  748,\n  750,\n  750,\n  880,\n  884,\n  886,\n  887,\n  890,\n  893,\n  902,\n  902,\n  904,\n  906,\n  908,\n  908,\n  910,\n  929,\n  931,\n  1013,\n  1015,\n  1153,\n  1162,\n  1319,\n  1329,\n  1366,\n  1369,\n  1369,\n  1377,\n  1415,\n  1488,\n  1514,\n  1520,\n  1522,\n  1568,\n  1610,\n  1646,\n  1647,\n  1649,\n  1747,\n  1749,\n  1749,\n  1765,\n  1766,\n  1774,\n  1775,\n  1786,\n  1788,\n  1791,\n  1791,\n  1808,\n  1808,\n  1810,\n  1839,\n  1869,\n  1957,\n  1969,\n  1969,\n  1994,\n  2026,\n  2036,\n  2037,\n  2042,\n  2042,\n  2048,\n  2069,\n  2074,\n  2074,\n  2084,\n  2084,\n  2088,\n  2088,\n  2112,\n  2136,\n  2308,\n  2361,\n  2365,\n  2365,\n  2384,\n  2384,\n  2392,\n  2401,\n  2417,\n  2423,\n  2425,\n  2431,\n  2437,\n  2444,\n  2447,\n  2448,\n  2451,\n  2472,\n  2474,\n  2480,\n  2482,\n  2482,\n  2486,\n  2489,\n  2493,\n  2493,\n  2510,\n  2510,\n  2524,\n  2525,\n  2527,\n  2529,\n  2544,\n  2545,\n  2565,\n  2570,\n  2575,\n  2576,\n  2579,\n  2600,\n  2602,\n  2608,\n  2610,\n  2611,\n  2613,\n  2614,\n  2616,\n  2617,\n  2649,\n  2652,\n  2654,\n  2654,\n  2674,\n  2676,\n  2693,\n  2701,\n  2703,\n  2705,\n  2707,\n  2728,\n  2730,\n  2736,\n  2738,\n  2739,\n  2741,\n  2745,\n  2749,\n  2749,\n  2768,\n  2768,\n  2784,\n  2785,\n  2821,\n  2828,\n  2831,\n  2832,\n  2835,\n  2856,\n  2858,\n  2864,\n  2866,\n  2867,\n  2869,\n  2873,\n  2877,\n  2877,\n  2908,\n  2909,\n  2911,\n  2913,\n  2929,\n  2929,\n  2947,\n  2947,\n  2949,\n  2954,\n  2958,\n  2960,\n  2962,\n  2965,\n  2969,\n  2970,\n  2972,\n  2972,\n  2974,\n  2975,\n  2979,\n  2980,\n  2984,\n  2986,\n  2990,\n  3001,\n  3024,\n  3024,\n  3077,\n  3084,\n  3086,\n  3088,\n  3090,\n  3112,\n  3114,\n  3123,\n  3125,\n  3129,\n  3133,\n  3133,\n  3160,\n  3161,\n  3168,\n  3169,\n  3205,\n  3212,\n  3214,\n  3216,\n  3218,\n  3240,\n  3242,\n  3251,\n  3253,\n  3257,\n  3261,\n  3261,\n  3294,\n  3294,\n  3296,\n  3297,\n  3313,\n  3314,\n  3333,\n  3340,\n  3342,\n  3344,\n  3346,\n  3386,\n  3389,\n  3389,\n  3406,\n  3406,\n  3424,\n  3425,\n  3450,\n  3455,\n  3461,\n  3478,\n  3482,\n  3505,\n  3507,\n  3515,\n  3517,\n  3517,\n  3520,\n  3526,\n  3585,\n  3632,\n  3634,\n  3635,\n  3648,\n  3654,\n  3713,\n  3714,\n  3716,\n  3716,\n  3719,\n  3720,\n  3722,\n  3722,\n  3725,\n  3725,\n  3732,\n  3735,\n  3737,\n  3743,\n  3745,\n  3747,\n  3749,\n  3749,\n  3751,\n  3751,\n  3754,\n  3755,\n  3757,\n  3760,\n  3762,\n  3763,\n  3773,\n  3773,\n  3776,\n  3780,\n  3782,\n  3782,\n  3804,\n  3805,\n  3840,\n  3840,\n  3904,\n  3911,\n  3913,\n  3948,\n  3976,\n  3980,\n  4096,\n  4138,\n  4159,\n  4159,\n  4176,\n  4181,\n  4186,\n  4189,\n  4193,\n  4193,\n  4197,\n  4198,\n  4206,\n  4208,\n  4213,\n  4225,\n  4238,\n  4238,\n  4256,\n  4293,\n  4304,\n  4346,\n  4348,\n  4348,\n  4352,\n  4680,\n  4682,\n  4685,\n  4688,\n  4694,\n  4696,\n  4696,\n  4698,\n  4701,\n  4704,\n  4744,\n  4746,\n  4749,\n  4752,\n  4784,\n  4786,\n  4789,\n  4792,\n  4798,\n  4800,\n  4800,\n  4802,\n  4805,\n  4808,\n  4822,\n  4824,\n  4880,\n  4882,\n  4885,\n  4888,\n  4954,\n  4992,\n  5007,\n  5024,\n  5108,\n  5121,\n  5740,\n  5743,\n  5759,\n  5761,\n  5786,\n  5792,\n  5866,\n  5870,\n  5872,\n  5888,\n  5900,\n  5902,\n  5905,\n  5920,\n  5937,\n  5952,\n  5969,\n  5984,\n  5996,\n  5998,\n  6000,\n  6016,\n  6067,\n  6103,\n  6103,\n  6108,\n  6108,\n  6176,\n  6263,\n  6272,\n  6312,\n  6314,\n  6314,\n  6320,\n  6389,\n  6400,\n  6428,\n  6480,\n  6509,\n  6512,\n  6516,\n  6528,\n  6571,\n  6593,\n  6599,\n  6656,\n  6678,\n  6688,\n  6740,\n  6823,\n  6823,\n  6917,\n  6963,\n  6981,\n  6987,\n  7043,\n  7072,\n  7086,\n  7087,\n  7104,\n  7141,\n  7168,\n  7203,\n  7245,\n  7247,\n  7258,\n  7293,\n  7401,\n  7404,\n  7406,\n  7409,\n  7424,\n  7615,\n  7680,\n  7957,\n  7960,\n  7965,\n  7968,\n  8005,\n  8008,\n  8013,\n  8016,\n  8023,\n  8025,\n  8025,\n  8027,\n  8027,\n  8029,\n  8029,\n  8031,\n  8061,\n  8064,\n  8116,\n  8118,\n  8124,\n  8126,\n  8126,\n  8130,\n  8132,\n  8134,\n  8140,\n  8144,\n  8147,\n  8150,\n  8155,\n  8160,\n  8172,\n  8178,\n  8180,\n  8182,\n  8188,\n  8305,\n  8305,\n  8319,\n  8319,\n  8336,\n  8348,\n  8450,\n  8450,\n  8455,\n  8455,\n  8458,\n  8467,\n  8469,\n  8469,\n  8473,\n  8477,\n  8484,\n  8484,\n  8486,\n  8486,\n  8488,\n  8488,\n  8490,\n  8493,\n  8495,\n  8505,\n  8508,\n  8511,\n  8517,\n  8521,\n  8526,\n  8526,\n  8544,\n  8584,\n  11264,\n  11310,\n  11312,\n  11358,\n  11360,\n  11492,\n  11499,\n  11502,\n  11520,\n  11557,\n  11568,\n  11621,\n  11631,\n  11631,\n  11648,\n  11670,\n  11680,\n  11686,\n  11688,\n  11694,\n  11696,\n  11702,\n  11704,\n  11710,\n  11712,\n  11718,\n  11720,\n  11726,\n  11728,\n  11734,\n  11736,\n  11742,\n  11823,\n  11823,\n  12293,\n  12295,\n  12321,\n  12329,\n  12337,\n  12341,\n  12344,\n  12348,\n  12353,\n  12438,\n  12445,\n  12447,\n  12449,\n  12538,\n  12540,\n  12543,\n  12549,\n  12589,\n  12593,\n  12686,\n  12704,\n  12730,\n  12784,\n  12799,\n  13312,\n  13312,\n  19893,\n  19893,\n  19968,\n  19968,\n  40907,\n  40907,\n  40960,\n  42124,\n  42192,\n  42237,\n  42240,\n  42508,\n  42512,\n  42527,\n  42538,\n  42539,\n  42560,\n  42606,\n  42623,\n  42647,\n  42656,\n  42735,\n  42775,\n  42783,\n  42786,\n  42888,\n  42891,\n  42894,\n  42896,\n  42897,\n  42912,\n  42921,\n  43002,\n  43009,\n  43011,\n  43013,\n  43015,\n  43018,\n  43020,\n  43042,\n  43072,\n  43123,\n  43138,\n  43187,\n  43250,\n  43255,\n  43259,\n  43259,\n  43274,\n  43301,\n  43312,\n  43334,\n  43360,\n  43388,\n  43396,\n  43442,\n  43471,\n  43471,\n  43520,\n  43560,\n  43584,\n  43586,\n  43588,\n  43595,\n  43616,\n  43638,\n  43642,\n  43642,\n  43648,\n  43695,\n  43697,\n  43697,\n  43701,\n  43702,\n  43705,\n  43709,\n  43712,\n  43712,\n  43714,\n  43714,\n  43739,\n  43741,\n  43777,\n  43782,\n  43785,\n  43790,\n  43793,\n  43798,\n  43808,\n  43814,\n  43816,\n  43822,\n  43968,\n  44002,\n  44032,\n  44032,\n  55203,\n  55203,\n  55216,\n  55238,\n  55243,\n  55291,\n  63744,\n  64045,\n  64048,\n  64109,\n  64112,\n  64217,\n  64256,\n  64262,\n  64275,\n  64279,\n  64285,\n  64285,\n  64287,\n  64296,\n  64298,\n  64310,\n  64312,\n  64316,\n  64318,\n  64318,\n  64320,\n  64321,\n  64323,\n  64324,\n  64326,\n  64433,\n  64467,\n  64829,\n  64848,\n  64911,\n  64914,\n  64967,\n  65008,\n  65019,\n  65136,\n  65140,\n  65142,\n  65276,\n  65313,\n  65338,\n  65345,\n  65370,\n  65382,\n  65470,\n  65474,\n  65479,\n  65482,\n  65487,\n  65490,\n  65495,\n  65498,\n  65500,\n  65536,\n  65547,\n  65549,\n  65574,\n  65576,\n  65594,\n  65596,\n  65597,\n  65599,\n  65613,\n  65616,\n  65629,\n  65664,\n  65786,\n  65856,\n  65908,\n  66176,\n  66204,\n  66208,\n  66256,\n  66304,\n  66334,\n  66352,\n  66378,\n  66432,\n  66461,\n  66464,\n  66499,\n  66504,\n  66511,\n  66513,\n  66517,\n  66560,\n  66717,\n  67584,\n  67589,\n  67592,\n  67592,\n  67594,\n  67637,\n  67639,\n  67640,\n  67644,\n  67644,\n  67647,\n  67669,\n  67840,\n  67861,\n  67872,\n  67897,\n  68096,\n  68096,\n  68112,\n  68115,\n  68117,\n  68119,\n  68121,\n  68147,\n  68192,\n  68220,\n  68352,\n  68405,\n  68416,\n  68437,\n  68448,\n  68466,\n  68608,\n  68680,\n  69635,\n  69687,\n  69763,\n  69807,\n  73728,\n  74606,\n  74752,\n  74850,\n  77824,\n  78894,\n  92160,\n  92728,\n  110592,\n  110593,\n  119808,\n  119892,\n  119894,\n  119964,\n  119966,\n  119967,\n  119970,\n  119970,\n  119973,\n  119974,\n  119977,\n  119980,\n  119982,\n  119993,\n  119995,\n  119995,\n  119997,\n  120003,\n  120005,\n  120069,\n  120071,\n  120074,\n  120077,\n  120084,\n  120086,\n  120092,\n  120094,\n  120121,\n  120123,\n  120126,\n  120128,\n  120132,\n  120134,\n  120134,\n  120138,\n  120144,\n  120146,\n  120485,\n  120488,\n  120512,\n  120514,\n  120538,\n  120540,\n  120570,\n  120572,\n  120596,\n  120598,\n  120628,\n  120630,\n  120654,\n  120656,\n  120686,\n  120688,\n  120712,\n  120714,\n  120744,\n  120746,\n  120770,\n  120772,\n  120779,\n  131072,\n  131072,\n  173782,\n  173782,\n  173824,\n  173824,\n  177972,\n  177972,\n  177984,\n  177984,\n  178205,\n  178205,\n  194560,\n  195101,\n];\n\nconst identifierStartTable: any[] = [];\n\nfor (let i = 0; i < 128; i++) {\n  identifierStartTable[i] =\n    (i >= 48 && i <= 57) || // 0-9\n    i === 36 || // $\n    i === 126 || // ~\n    i === 124 || // |\n    (i >= 65 && i <= 90) || // A-Z\n    i === 95 || // _\n    i === 45 || // -\n    i === 42 || // *\n    i === 58 || // :\n    i === 91 || // templateStart [\n    i === 93 || // templateEnd ]\n    i === 63 || // ?\n    i === 37 || // %\n    i === 35 || // #\n    i === 61 || // =\n    (i >= 97 && i <= 122); // a-z\n}\n\nconst identifierPartTable = identifierStartTable;\n\nexport class Lexer {\n  input: any;\n  char: number;\n  from: number;\n\n  constructor(expression: any) {\n    this.input = expression;\n    this.char = 1;\n    this.from = 1;\n  }\n\n  peek(i?: number) {\n    return this.input.charAt(i || 0);\n  }\n\n  skip(i?: number) {\n    i = i || 1;\n    this.char += i;\n    this.input = this.input.slice(i);\n  }\n\n  tokenize() {\n    const list = [];\n    let token = this.next();\n    while (token) {\n      list.push(token);\n      token = this.next();\n    }\n    return list;\n  }\n\n  next() {\n    this.from = this.char;\n\n    // Move to the next non-space character.\n    if (/\\s/.test(this.peek())) {\n      while (/\\s/.test(this.peek())) {\n        this.from += 1;\n        this.skip();\n      }\n\n      if (this.peek() === '') {\n        // EOL\n        return null;\n      }\n    }\n\n    let match = this.scanStringLiteral();\n    if (match) {\n      return match;\n    }\n\n    match = this.scanPunctuator() || this.scanNumericLiteral() || this.scanIdentifier() || this.scanTemplateSequence();\n\n    if (match) {\n      this.skip(match.value.length);\n      return match;\n    }\n\n    // No token could be matched, give up.\n    return null;\n  }\n\n  scanTemplateSequence() {\n    if (this.peek() === '[' && this.peek(1) === '[') {\n      return {\n        type: 'templateStart',\n        value: '[[',\n        pos: this.char,\n      };\n    }\n\n    if (this.peek() === ']' && this.peek(1) === ']') {\n      return {\n        type: 'templateEnd',\n        value: '[[',\n        pos: this.char,\n      };\n    }\n\n    return null;\n  }\n\n  /*\n   * Extract a JavaScript identifier out of the next sequence of\n   * characters or return 'null' if its not possible. In addition,\n   * to Identifier this method can also produce BooleanLiteral\n   * (true/false) and NullLiteral (null).\n   */\n  scanIdentifier() {\n    let id = '';\n    let index = 0;\n    let type, char;\n\n    // Detects any character in the Unicode categories \"Uppercase\n    // letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\n    // (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\n    // \"Letter number (Nl)\".\n    //\n    // Both approach and unicodeLetterTable were borrowed from\n    // Google's Traceur.\n\n    function isUnicodeLetter(code: number) {\n      for (let i = 0; i < unicodeLetterTable.length; ) {\n        if (code < unicodeLetterTable[i++]) {\n          return false;\n        }\n\n        if (code <= unicodeLetterTable[i++]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isHexDigit(str: string) {\n      return /^[0-9a-fA-F]$/.test(str);\n    }\n\n    const readUnicodeEscapeSequence = bind(function (this: any) {\n      index += 1;\n\n      if (this.peek(index) !== 'u') {\n        return null;\n      }\n\n      const ch1 = this.peek(index + 1);\n      const ch2 = this.peek(index + 2);\n      const ch3 = this.peek(index + 3);\n      const ch4 = this.peek(index + 4);\n      let code;\n\n      if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\n        code = parseInt(ch1 + ch2 + ch3 + ch4, 16);\n\n        if (isUnicodeLetter(code)) {\n          index += 5;\n          return '\\\\u' + ch1 + ch2 + ch3 + ch4;\n        }\n\n        return null;\n      }\n\n      return null;\n    }, this);\n\n    const getIdentifierStart = bind(function (this: any) {\n      const chr = this.peek(index);\n      const code = chr.charCodeAt(0);\n\n      if (chr === '*') {\n        index += 1;\n        return chr;\n      }\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierStartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }, this);\n\n    const getIdentifierPart = bind(function (this: any) {\n      const chr = this.peek(index);\n      const code = chr.charCodeAt(0);\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierPartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }, this);\n\n    char = getIdentifierStart();\n    if (char === null) {\n      return null;\n    }\n\n    id = char;\n    for (;;) {\n      char = getIdentifierPart();\n\n      if (char === null) {\n        break;\n      }\n\n      id += char;\n    }\n\n    switch (id) {\n      case 'true': {\n        type = 'bool';\n        break;\n      }\n      case 'false': {\n        type = 'bool';\n        break;\n      }\n      default:\n        type = 'identifier';\n    }\n\n    return {\n      type: type,\n      value: id,\n      pos: this.char,\n    };\n  }\n\n  /*\n   * Extract a numeric literal out of the next sequence of\n   * characters or return 'null' if its not possible. This method\n   * supports all numeric literals described in section 7.8.3\n   * of the EcmaScript 5 specification.\n   *\n   * This method's implementation was heavily influenced by the\n   * scanNumericLiteral function in the Esprima parser's source code.\n   */\n  scanNumericLiteral(): any {\n    let index = 0;\n    let value = '';\n    const length = this.input.length;\n    let char = this.peek(index);\n    let bad;\n\n    function isDecimalDigit(str: string) {\n      return /^[0-9]$/.test(str);\n    }\n\n    function isOctalDigit(str: string) {\n      return /^[0-7]$/.test(str);\n    }\n\n    function isHexDigit(str: string) {\n      return /^[0-9a-fA-F]$/.test(str);\n    }\n\n    function isIdentifierStart(ch: string) {\n      return ch === '$' || ch === '_' || ch === '\\\\' || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n    }\n\n    // handle negative num literals\n    if (char === '-') {\n      value += char;\n      index += 1;\n      char = this.peek(index);\n    }\n\n    // Numbers must start either with a decimal digit or a point.\n    if (char !== '.' && !isDecimalDigit(char)) {\n      return null;\n    }\n\n    if (char !== '.') {\n      value += this.peek(index);\n      index += 1;\n      char = this.peek(index);\n\n      if (value === '0') {\n        // Base-16 numbers.\n        if (char === 'x' || char === 'X') {\n          index += 1;\n          value += char;\n\n          while (index < length) {\n            char = this.peek(index);\n            if (!isHexDigit(char)) {\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (value.length <= 2) {\n            // 0x\n            return {\n              type: 'number',\n              value: value,\n              isMalformed: true,\n              pos: this.char,\n            };\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: 'number',\n            value: value,\n            base: 16,\n            isMalformed: false,\n            pos: this.char,\n          };\n        }\n\n        // Base-8 numbers.\n        if (isOctalDigit(char)) {\n          index += 1;\n          value += char;\n          bad = false;\n\n          while (index < length) {\n            char = this.peek(index);\n\n            // Numbers like '019' (note the 9) are not valid octals\n            // but we still parse them and mark as malformed.\n\n            if (isDecimalDigit(char)) {\n              bad = true;\n            }\n            if (!isOctalDigit(char)) {\n              // if the char is a non punctuator then its not a valid number\n              if (!this.isPunctuator(char)) {\n                return null;\n              }\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: 'number',\n            value: value,\n            base: 8,\n            isMalformed: bad,\n          };\n        }\n\n        // Decimal numbers that start with '0' such as '09' are illegal\n        // but we still parse them and return as malformed.\n\n        if (isDecimalDigit(char)) {\n          index += 1;\n          value += char;\n        }\n      }\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Decimal digits.\n\n    if (char === '.') {\n      value += char;\n      index += 1;\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Exponent part.\n\n    if (char === 'e' || char === 'E') {\n      value += char;\n      index += 1;\n      char = this.peek(index);\n\n      if (char === '+' || char === '-') {\n        value += this.peek(index);\n        index += 1;\n      }\n\n      char = this.peek(index);\n      if (isDecimalDigit(char)) {\n        value += char;\n        index += 1;\n\n        while (index < length) {\n          char = this.peek(index);\n          if (!isDecimalDigit(char)) {\n            break;\n          }\n          value += char;\n          index += 1;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    if (index < length) {\n      char = this.peek(index);\n      if (!this.isPunctuator(char)) {\n        return null;\n      }\n    }\n\n    return {\n      type: 'number',\n      value: value,\n      base: 10,\n      pos: this.char,\n      isMalformed: !isFinite(+value),\n    };\n  }\n\n  isPunctuator(ch1: string) {\n    switch (ch1) {\n      case '.':\n      case '(':\n      case ')':\n      case ',':\n      case '{':\n      case '}':\n        return true;\n    }\n\n    return false;\n  }\n\n  scanPunctuator() {\n    const ch1 = this.peek();\n\n    if (this.isPunctuator(ch1)) {\n      return {\n        type: ch1,\n        value: ch1,\n        pos: this.char,\n      };\n    }\n\n    return null;\n  }\n\n  /*\n   * Extract a string out of the next sequence of characters and/or\n   * lines or return 'null' if its not possible. Since strings can\n   * span across multiple lines this method has to move the char\n   * pointer.\n   *\n   * This method recognizes pseudo-multiline JavaScript strings:\n   *\n   *   var str = \"hello\\\n   *   world\";\n   */\n  scanStringLiteral() {\n    const quote = this.peek();\n\n    // String must start with a quote.\n    if (quote !== '\"' && quote !== \"'\") {\n      return null;\n    }\n\n    let value = '';\n\n    this.skip();\n\n    while (this.peek() !== quote) {\n      if (this.peek() === '') {\n        // End Of Line\n        return {\n          type: 'string',\n          value: value,\n          isUnclosed: true,\n          quote: quote,\n          pos: this.char,\n        };\n      }\n\n      const char = this.peek();\n      const jump = 1; // A length of a jump, after we're done\n      // parsing this character.\n\n      value += char;\n      this.skip(jump);\n    }\n\n    this.skip();\n    return {\n      type: 'string',\n      value: value,\n      isUnclosed: false,\n      quote: quote,\n      pos: this.char,\n    };\n  }\n}\n","import { Lexer } from './lexer';\n\nexport class Parser {\n  expression: any;\n  lexer: Lexer;\n  tokens: any;\n  index: number;\n\n  constructor(expression: any) {\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  getAst() {\n    return this.start();\n  }\n\n  start() {\n    try {\n      return this.functionCall() || this.metricExpression();\n    } catch (e) {\n      return {\n        type: 'error',\n        message: e.message,\n        pos: e.pos,\n      };\n    }\n  }\n\n  curlyBraceSegment() {\n    if (this.match('identifier', '{') || this.match('{')) {\n      let curlySegment = '';\n\n      while (!this.match('') && !this.match('}')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      if (!this.match('}')) {\n        this.errorMark(\"Expected closing '}'\");\n      }\n\n      curlySegment += this.consumeToken().value;\n\n      // if curly segment is directly followed by identifier\n      // include it in the segment\n      if (this.match('identifier')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      return {\n        type: 'segment',\n        value: curlySegment,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  metricSegment() {\n    const curly = this.curlyBraceSegment();\n    if (curly) {\n      return curly;\n    }\n\n    if (this.match('identifier') || this.match('number')) {\n      // hack to handle float numbers in metric segments\n      const parts = this.consumeToken().value.split('.');\n      if (parts.length === 2) {\n        this.tokens.splice(this.index, 0, { type: '.' });\n        this.tokens.splice(this.index + 1, 0, {\n          type: 'number',\n          value: parts[1],\n        });\n      }\n\n      return {\n        type: 'segment',\n        value: parts[0],\n      };\n    }\n\n    if (!this.match('templateStart')) {\n      this.errorMark('Expected metric identifier');\n    }\n\n    this.consumeToken();\n\n    if (!this.match('identifier')) {\n      this.errorMark('Expected identifier after templateStart');\n    }\n\n    const node = {\n      type: 'template',\n      value: this.consumeToken().value,\n    };\n\n    if (!this.match('templateEnd')) {\n      this.errorMark('Expected templateEnd');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  metricExpression() {\n    if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'metric',\n      segments: [],\n    };\n\n    node.segments.push(this.metricSegment());\n\n    while (this.match('.')) {\n      this.consumeToken();\n\n      const segment = this.metricSegment();\n      if (!segment) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      node.segments.push(segment);\n    }\n\n    return node;\n  }\n\n  functionCall() {\n    if (!this.match('identifier', '(')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'function',\n      name: this.consumeToken().value,\n    };\n\n    // consume left parenthesis\n    this.consumeToken();\n\n    node.params = this.functionParameters();\n\n    if (!this.match(')')) {\n      this.errorMark('Expected closing parenthesis');\n    }\n\n    this.consumeToken();\n\n    return node;\n  }\n\n  boolExpression() {\n    if (!this.match('bool')) {\n      return null;\n    }\n\n    return {\n      type: 'bool',\n      value: this.consumeToken().value === 'true',\n    };\n  }\n\n  functionParameters(): any {\n    if (this.match(')') || this.match('')) {\n      return [];\n    }\n\n    const param =\n      this.functionCall() ||\n      this.numericLiteral() ||\n      this.seriesRefExpression() ||\n      this.boolExpression() ||\n      this.metricExpression() ||\n      this.stringLiteral();\n\n    if (!this.match(',')) {\n      return [param];\n    }\n\n    this.consumeToken();\n    return [param].concat(this.functionParameters());\n  }\n\n  seriesRefExpression() {\n    if (!this.match('identifier')) {\n      return null;\n    }\n\n    const value = this.tokens[this.index].value;\n    if (!value.match(/\\#[A-Z]/)) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n\n    return {\n      type: 'series-ref',\n      value: token.value,\n    };\n  }\n\n  numericLiteral() {\n    if (!this.match('number')) {\n      return null;\n    }\n\n    return {\n      type: 'number',\n      value: parseFloat(this.consumeToken().value),\n    };\n  }\n\n  stringLiteral() {\n    if (!this.match('string')) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n    if (token.isUnclosed) {\n      throw { message: 'Unclosed string parameter', pos: token.pos };\n    }\n\n    return {\n      type: 'string',\n      value: token.value,\n    };\n  }\n\n  errorMark(text: string) {\n    const currentToken = this.tokens[this.index];\n    const type = currentToken ? currentToken.type : 'end of string';\n    throw {\n      message: text + ' instead found ' + type,\n      pos: currentToken ? currentToken.pos : this.lexer.char,\n    };\n  }\n\n  // returns token value and incre\n  consumeToken() {\n    this.index++;\n    return this.tokens[this.index - 1];\n  }\n\n  matchToken(type: any, index: number) {\n    const token = this.tokens[this.index + index];\n    return (token === undefined && type === '') || (token && token.type === type);\n  }\n\n  match(token1: any, token2?: any) {\n    return this.matchToken(token1, 0) && (!token2 || this.matchToken(token2, 1));\n  }\n}\n","import { compact, each, findIndex, flatten, get, join, keyBy, last, map, reduce, without } from 'lodash';\nimport { arrayMove } from 'app/core/utils/arrayMove';\nimport { Parser } from './parser';\nimport { TemplateSrv } from '@grafana/runtime';\nimport { ScopedVars } from '@grafana/data';\nimport { FuncInstance } from './gfunc';\nimport { GraphiteSegment } from './types';\nimport { GraphiteDatasource } from './datasource';\n\nexport type GraphiteTagOperator = '=' | '=~' | '!=' | '!=~';\n\nexport type GraphiteTag = {\n  key: string;\n  operator: GraphiteTagOperator;\n  value: string;\n};\n\nexport type GraphiteTarget = {\n  refId: string | number;\n  target: string;\n  /**\n   * Contains full query after interpolating sub-queries (e.g. \"function(#A)\" referencing query with refId=A)\n   */\n  targetFull: string;\n  textEditor: boolean;\n  paused: boolean;\n};\n\nexport default class GraphiteQuery {\n  datasource: GraphiteDatasource;\n  target: GraphiteTarget;\n  functions: FuncInstance[] = [];\n  segments: GraphiteSegment[] = [];\n  tags: GraphiteTag[] = [];\n  error: any;\n  seriesByTagUsed = false;\n  checkOtherSegmentsIndex = 0;\n  removeTagValue: string;\n  templateSrv: any;\n  scopedVars: any;\n\n  /** @ngInject */\n  constructor(datasource: any, target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.datasource = datasource;\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    this.parseTarget();\n\n    this.removeTagValue = '-- remove tag --';\n  }\n\n  parseTarget() {\n    this.functions = [];\n    this.segments = [];\n    this.tags = [];\n    this.seriesByTagUsed = false;\n    this.error = null;\n\n    if (this.target.textEditor) {\n      return;\n    }\n\n    const parser = new Parser(this.target.target);\n    const astNode = parser.getAst();\n    if (astNode === null) {\n      this.checkOtherSegmentsIndex = 0;\n      return;\n    }\n\n    if (astNode.type === 'error') {\n      this.error = astNode.message + ' at position: ' + astNode.pos;\n      this.target.textEditor = true;\n      return;\n    }\n\n    try {\n      this.parseTargetRecursive(astNode, null);\n    } catch (err) {\n      console.error('error parsing target:', err.message);\n      this.error = err.message;\n      this.target.textEditor = true;\n    }\n\n    this.checkOtherSegmentsIndex = this.segments.length - 1;\n  }\n\n  getSegmentPathUpTo(index: number) {\n    const arr = this.segments.slice(0, index);\n\n    return reduce(\n      arr,\n      (result, segment) => {\n        return result ? result + '.' + segment.value : segment.value;\n      },\n      ''\n    );\n  }\n\n  parseTargetRecursive(astNode: any, func: any): any {\n    if (astNode === null) {\n      return null;\n    }\n\n    switch (astNode.type) {\n      case 'function':\n        const innerFunc = this.datasource.createFuncInstance(astNode.name, {\n          withDefaultParams: false,\n        });\n        each(astNode.params, (param) => {\n          this.parseTargetRecursive(param, innerFunc);\n        });\n\n        innerFunc.updateText();\n        this.functions.push(innerFunc);\n\n        // extract tags from seriesByTag function and hide function\n        if (innerFunc.def.name === 'seriesByTag' && !this.seriesByTagUsed) {\n          this.seriesByTagUsed = true;\n          innerFunc.hidden = true;\n          this.tags = this.splitSeriesByTagParams(innerFunc);\n        }\n\n        break;\n      case 'series-ref':\n        if (this.segments.length > 0 || this.getSeriesByTagFuncIndex() >= 0) {\n          this.addFunctionParameter(func, astNode.value);\n        } else {\n          this.segments.push(astNode);\n        }\n        break;\n      case 'bool':\n      case 'string':\n      case 'number':\n        this.addFunctionParameter(func, astNode.value);\n        break;\n      case 'metric':\n        if (this.segments.length || this.tags.length) {\n          this.addFunctionParameter(func, join(map(astNode.segments, 'value'), '.'));\n        } else {\n          this.segments = astNode.segments;\n        }\n        break;\n    }\n  }\n\n  updateSegmentValue(segment: any, index: number) {\n    this.segments[index].value = segment.value;\n  }\n\n  addSelectMetricSegment() {\n    this.segments.push({ value: 'select metric' });\n  }\n\n  addFunction(newFunc: any) {\n    this.functions.push(newFunc);\n  }\n\n  addFunctionParameter(func: any, value: string) {\n    if (func.params.length >= func.def.params.length && !get(last(func.def.params), 'multiple', false)) {\n      throw { message: 'too many parameters for function ' + func.def.name };\n    }\n    func.params.push(value);\n  }\n\n  removeFunction(func: any) {\n    this.functions = without(this.functions, func);\n  }\n\n  moveFunction(func: any, offset: number) {\n    const index = this.functions.indexOf(func);\n    arrayMove(this.functions, index, index + offset);\n  }\n\n  updateModelTarget(targets: any) {\n    const wrapFunction = (target: string, func: any) => {\n      return func.render(target, (value: string) => {\n        return this.templateSrv.replace(value, this.scopedVars);\n      });\n    };\n\n    if (!this.target.textEditor) {\n      const metricPath = this.getSegmentPathUpTo(this.segments.length).replace(/\\.?select metric$/, '');\n      this.target.target = reduce(this.functions, wrapFunction, metricPath);\n    }\n\n    this.updateRenderedTarget(this.target, targets);\n\n    // loop through other queries and update targetFull as needed\n    for (const target of targets || []) {\n      if (target.refId !== this.target.refId) {\n        this.updateRenderedTarget(target, targets);\n      }\n    }\n\n    // clean-up added param\n    this.functions.forEach((func) => (func.added = false));\n  }\n\n  updateRenderedTarget(target: { refId: string | number; target: any; targetFull: any }, targets: any) {\n    // render nested query\n    const targetsByRefId = keyBy(targets, 'refId');\n\n    // no references to self\n    delete targetsByRefId[target.refId];\n\n    const nestedSeriesRefRegex = /\\#([A-Z])/g;\n    let targetWithNestedQueries = target.target;\n\n    // Use ref count to track circular references\n    function countTargetRefs(targetsByRefId: any, refId: string) {\n      let refCount = 0;\n      each(targetsByRefId, (t, id) => {\n        if (id !== refId) {\n          const match = nestedSeriesRefRegex.exec(t.target);\n          const count = match && match.length ? match.length - 1 : 0;\n          refCount += count;\n        }\n      });\n      targetsByRefId[refId].refCount = refCount;\n    }\n    each(targetsByRefId, (t, id) => {\n      countTargetRefs(targetsByRefId, id);\n    });\n\n    // Keep interpolating until there are no query references\n    // The reason for the loop is that the referenced query might contain another reference to another query\n    while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {\n      const updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, (match: string, g1: string) => {\n        const t = targetsByRefId[g1];\n        if (!t) {\n          return match;\n        }\n\n        // no circular references\n        if (t.refCount === 0) {\n          delete targetsByRefId[g1];\n        }\n        t.refCount--;\n\n        return t.target;\n      });\n\n      if (updated === targetWithNestedQueries) {\n        break;\n      }\n\n      targetWithNestedQueries = updated;\n    }\n\n    delete target.targetFull;\n    if (target.target !== targetWithNestedQueries) {\n      target.targetFull = targetWithNestedQueries;\n    }\n  }\n\n  splitSeriesByTagParams(func: { params: any }) {\n    const tagPattern = /([^\\!=~]+)(\\!?=~?)(.*)/;\n    return flatten(\n      map(func.params, (param: string) => {\n        const matches = tagPattern.exec(param);\n        if (matches) {\n          const tag = matches.slice(1);\n          if (tag.length === 3) {\n            return {\n              key: tag[0],\n              operator: tag[1] as GraphiteTagOperator,\n              value: tag[2],\n            };\n          }\n        }\n        return [];\n      })\n    );\n  }\n\n  getSeriesByTagFuncIndex() {\n    return findIndex(this.functions, (func) => func.def.name === 'seriesByTag');\n  }\n\n  getSeriesByTagFunc() {\n    const seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();\n    if (seriesByTagFuncIndex >= 0) {\n      return this.functions[seriesByTagFuncIndex];\n    } else {\n      return undefined;\n    }\n  }\n\n  addTag(tag: { key: any; operator: GraphiteTagOperator; value: string }) {\n    const newTagParam = renderTagString(tag);\n    this.getSeriesByTagFunc()!.params.push(newTagParam);\n    this.tags.push(tag);\n  }\n\n  removeTag(index: number) {\n    this.getSeriesByTagFunc()!.params.splice(index, 1);\n    this.tags.splice(index, 1);\n  }\n\n  updateTag(tag: { key: string; operator: GraphiteTagOperator; value: string }, tagIndex: number) {\n    this.error = null;\n\n    if (tag.key === this.removeTagValue) {\n      this.removeTag(tagIndex);\n      if (this.tags.length === 0) {\n        this.removeFunction(this.getSeriesByTagFunc());\n        this.checkOtherSegmentsIndex = 0;\n        this.seriesByTagUsed = false;\n      }\n      return;\n    }\n\n    this.getSeriesByTagFunc()!.params[tagIndex] = renderTagString(tag);\n    this.tags[tagIndex] = tag;\n  }\n\n  renderTagExpressions(excludeIndex = -1) {\n    return compact(\n      map(this.tags, (tagExpr, index) => {\n        // Don't render tag that we want to lookup\n        if (index !== excludeIndex) {\n          return tagExpr.key + tagExpr.operator + tagExpr.value;\n        } else {\n          return undefined;\n        }\n      })\n    );\n  }\n}\n\nfunction renderTagString(tag: { key: any; operator?: any; value?: any }) {\n  return tag.key + tag.operator + tag.value;\n}\n"],"names":["unicodeLetterTable","identifierStartTable","i","identifierPartTable","Lexer","constructor","expression","this","input","char","from","peek","charAt","skip","slice","tokenize","list","token","next","push","test","match","scanStringLiteral","scanPunctuator","scanNumericLiteral","scanIdentifier","scanTemplateSequence","value","length","type","pos","id","index","isUnicodeLetter","code","isHexDigit","str","readUnicodeEscapeSequence","bind","ch1","ch2","ch3","ch4","parseInt","getIdentifierStart","chr","charCodeAt","getIdentifierPart","bad","isDecimalDigit","isOctalDigit","isIdentifierStart","ch","isMalformed","base","isPunctuator","isFinite","quote","isUnclosed","jump","Parser","lexer","tokens","getAst","start","functionCall","metricExpression","e","message","curlyBraceSegment","curlySegment","consumeToken","errorMark","metricSegment","curly","parts","split","splice","node","segments","segment","name","params","functionParameters","boolExpression","param","numericLiteral","seriesRefExpression","stringLiteral","concat","parseFloat","text","currentToken","matchToken","undefined","token1","token2","GraphiteQuery","datasource","target","templateSrv","scopedVars","parseTarget","removeTagValue","functions","tags","seriesByTagUsed","error","textEditor","astNode","parseTargetRecursive","err","console","checkOtherSegmentsIndex","getSegmentPathUpTo","arr","reduce","result","func","innerFunc","createFuncInstance","withDefaultParams","each","updateText","def","hidden","splitSeriesByTagParams","getSeriesByTagFuncIndex","addFunctionParameter","join","map","updateSegmentValue","addSelectMetricSegment","addFunction","newFunc","get","last","removeFunction","without","moveFunction","offset","indexOf","arrayMove","updateModelTarget","targets","wrapFunction","render","replace","metricPath","updateRenderedTarget","refId","forEach","added","targetsByRefId","keyBy","nestedSeriesRefRegex","targetWithNestedQueries","t","refCount","exec","count","countTargetRefs","updated","g1","targetFull","tagPattern","flatten","matches","tag","key","operator","findIndex","getSeriesByTagFunc","seriesByTagFuncIndex","addTag","newTagParam","renderTagString","removeTag","updateTag","tagIndex","renderTagExpressions","excludeIndex","compact","tagExpr"],"sourceRoot":""}