{"version":3,"file":"opentsdbPlugin.1f65f885c5a67f13d9d6.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/opentsdb/datasource.ts","webpack://grafana/./public/app/plugins/datasource/opentsdb/query_ctrl.ts","webpack://grafana/./public/app/plugins/datasource/opentsdb/components/OpenTsdbDetails.tsx","webpack://grafana/./public/app/plugins/datasource/opentsdb/module.ts","webpack://grafana/./public/app/plugins/datasource/opentsdb/components/ConfigEditor.tsx"],"sourcesContent":["import angular from 'angular';\nimport {\n  clone,\n  compact,\n  each,\n  every,\n  filter,\n  findIndex,\n  has,\n  includes,\n  isArray,\n  isEmpty,\n  map as _map,\n  toPairs,\n} from 'lodash';\nimport { lastValueFrom, Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport {\n  AnnotationEvent,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  dateMath,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\n\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  lookupLimit: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  constructor(instanceSettings: any, private readonly templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest<OpenTsdbQuery>): Observable<DataQueryResponse> {\n    const start = this.convertToTSDBTime(options.range.raw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.range.raw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    each(options.targets, (target) => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(queries)) {\n      return of({ data: [] });\n    }\n\n    const groupByTags: any = {};\n    each(queries, (query) => {\n      if (query.filters && query.filters.length > 0) {\n        each(query.filters, (val) => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = filter(options.targets, (query) => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).pipe(\n      catchError((err) => {\n        // Throw the error message here instead of the whole object to workaround the error parsing error.\n        throw err?.data?.error?.message || 'Error performing time series query.';\n      }),\n      map((response) => {\n        const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n        const result = _map(response.data, (metricData: any, index: number) => {\n          index = metricToTargetMapping[index];\n          if (index === -1) {\n            index = 0;\n          }\n          this._saveTagKeys(metricData);\n\n          return this.transformMetricData(\n            metricData,\n            groupByTags,\n            options.targets[index],\n            options,\n            this.tsdbResolution\n          );\n        });\n        return { data: result };\n      })\n    );\n  }\n\n  annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = compact(qs);\n\n    return lastValueFrom(\n      this.performTimeSeriesQuery(queries, start, end).pipe(\n        map((results) => {\n          if (results.data[0]) {\n            let annotationObject = results.data[0].annotations;\n            if (options.annotation.isGlobal) {\n              annotationObject = results.data[0].globalAnnotations;\n            }\n            if (annotationObject) {\n              each(annotationObject, (annotation) => {\n                const event = {\n                  text: annotation.description,\n                  time: Math.floor(annotation.startTime) * 1000,\n                  annotation: options.annotation,\n                };\n\n                eventList.push(event);\n              });\n            }\n          }\n          return eventList;\n        })\n      )\n    );\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any): Observable<FetchResponse> {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return getBackendSrv().fetch(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    each(metricData.aggregateTags, (tag) => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string): Observable<any> {\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).pipe(\n      map((result: any) => {\n        return result.data;\n      })\n    );\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any): Observable<any[]> {\n    if (!metric || !keys) {\n      return of([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagvs: any[] = [];\n        each(result, (r) => {\n          if (tagvs.indexOf(r.tags[key]) === -1) {\n            tagvs.push(r.tags[key]);\n          }\n        });\n        return tagvs;\n      })\n    );\n  }\n\n  _performMetricKeyLookup(metric: any): Observable<any[]> {\n    if (!metric) {\n      return of([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagks: any[] = [];\n        each(result, (r) => {\n          each(r.tags, (tagv, tagk) => {\n            if (tagks.indexOf(tagk) === -1) {\n              tagks.push(tagk);\n            }\n          });\n        });\n        return tagks;\n      })\n    );\n  }\n\n  _get(\n    relativeUrl: string,\n    params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }\n  ): Observable<FetchResponse> {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().fetch(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _map(result, (value) => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return lastValueFrom(this._performSuggestQuery(metricsQuery[1], 'metrics').pipe(map(responseTransform)));\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return lastValueFrom(this._performMetricKeyLookup(tagNamesQuery[1]).pipe(map(responseTransform)));\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return lastValueFrom(\n        this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).pipe(map(responseTransform))\n      );\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').pipe(map(responseTransform)));\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').pipe(map(responseTransform)));\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return lastValueFrom(\n      this._performSuggestQuery('cpu', 'metrics').pipe(\n        map(() => {\n          return { status: 'success', message: 'Data source is working' };\n        })\n      )\n    );\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = lastValueFrom(\n      this._get('/api/aggregators').pipe(\n        map((result: any) => {\n          if (result.data && isArray(result.data)) {\n            return result.data.sort();\n          }\n          return [];\n        })\n      )\n    );\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = lastValueFrom(\n      this._get('/api/config/filters').pipe(\n        map((result: any) => {\n          if (result.data) {\n            return Object.keys(result.data).sort();\n          }\n          return [];\n        })\n      )\n    );\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use pairs(invert()) because it stringifies keys/values\n    each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = clone(options.scopedVars || {});\n      each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!isEmpty(md.tags)) {\n      each(toPairs(md.tags), (tag) => {\n        if (has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _map(metrics, (metricData) => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return findIndex(options.targets as any[], (target) => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  interpolateVariablesInQueries(queries: OpenTsdbQuery[], scopedVars: ScopedVars): OpenTsdbQuery[] {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map((query) => ({\n      ...query,\n      metric: this.templateSrv.replace(query.metric, scopedVars),\n    }));\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n","import { map, size, has } from 'lodash';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\nimport { textUtil, rangeUtil } from '@grafana/data';\n\nexport class OpenTsQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  aggregators: any;\n  fillPolicies: any;\n  filterTypes: any;\n  tsdbVersion: any;\n  aggregator: any;\n  downsampleInterval: any;\n  downsampleAggregator: any;\n  downsampleFillPolicy: any;\n  errors: any;\n  suggestMetrics: any;\n  suggestTagKeys: any;\n  suggestTagValues: any;\n  addTagMode = false;\n  addFilterMode = false;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.errors = this.validateTarget();\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\n    this.filterTypes = [\n      'wildcard',\n      'iliteral_or',\n      'not_iliteral_or',\n      'not_literal_or',\n      'iwildcard',\n      'literal_or',\n      'regexp',\n    ];\n\n    this.tsdbVersion = this.datasource.tsdbVersion;\n\n    if (!this.target.aggregator) {\n      this.target.aggregator = 'sum';\n    }\n\n    if (!this.target.downsampleAggregator) {\n      this.target.downsampleAggregator = 'avg';\n    }\n\n    if (!this.target.downsampleFillPolicy) {\n      this.target.downsampleFillPolicy = 'none';\n    }\n\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\n      if (aggs.length !== 0) {\n        this.aggregators = aggs;\n      }\n    });\n\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\n      if (filterTypes.length !== 0) {\n        this.filterTypes = filterTypes;\n      }\n    });\n\n    // needs to be defined here as it is called from typeahead\n    this.suggestMetrics = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('metrics(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n\n    this.suggestTagKeys = (query: any, callback: any) => {\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\n    };\n\n    this.suggestTagValues = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('suggest_tagv(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n  }\n\n  targetBlur() {\n    this.errors = this.validateTarget();\n    this.refresh();\n  }\n\n  getTextValues(metricFindResult: any) {\n    return map(metricFindResult, (value) => {\n      return textUtil.escapeHtml(value.text);\n    });\n  }\n\n  addTag() {\n    if (this.target.filters && this.target.filters.length > 0) {\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addTagMode) {\n      this.addTagMode = true;\n      return;\n    }\n\n    if (!this.target.tags) {\n      this.target.tags = {};\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.tags) {\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\n      this.target.currentTagKey = '';\n      this.target.currentTagValue = '';\n      this.targetBlur();\n    }\n\n    this.addTagMode = false;\n  }\n\n  removeTag(key: string | number) {\n    delete this.target.tags[key];\n    this.targetBlur();\n  }\n\n  editTag(key: string | number, value: any) {\n    this.removeTag(key);\n    this.target.currentTagKey = key;\n    this.target.currentTagValue = value;\n    this.addTag();\n  }\n\n  closeAddTagMode() {\n    this.addTagMode = false;\n    return;\n  }\n\n  addFilter() {\n    if (this.target.tags && size(this.target.tags) > 0) {\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addFilterMode) {\n      this.addFilterMode = true;\n      return;\n    }\n\n    if (!this.target.filters) {\n      this.target.filters = [];\n    }\n\n    if (!this.target.currentFilterType) {\n      this.target.currentFilterType = 'iliteral_or';\n    }\n\n    if (!this.target.currentFilterGroupBy) {\n      this.target.currentFilterGroupBy = false;\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.filters) {\n      const currentFilter = {\n        type: this.target.currentFilterType,\n        tagk: this.target.currentFilterKey,\n        filter: this.target.currentFilterValue,\n        groupBy: this.target.currentFilterGroupBy,\n      };\n      this.target.filters.push(currentFilter);\n      this.target.currentFilterType = 'literal_or';\n      this.target.currentFilterKey = '';\n      this.target.currentFilterValue = '';\n      this.target.currentFilterGroupBy = false;\n      this.targetBlur();\n    }\n\n    this.addFilterMode = false;\n  }\n\n  removeFilter(index: number) {\n    this.target.filters.splice(index, 1);\n    this.targetBlur();\n  }\n\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\n    this.removeFilter(index);\n    this.target.currentFilterKey = fil.tagk;\n    this.target.currentFilterValue = fil.filter;\n    this.target.currentFilterType = fil.type;\n    this.target.currentFilterGroupBy = fil.groupBy;\n    this.addFilter();\n  }\n\n  closeAddFilterMode() {\n    this.addFilterMode = false;\n    return;\n  }\n\n  validateTarget() {\n    const errs: any = {};\n\n    if (this.target.shouldDownsample) {\n      try {\n        if (this.target.downsampleInterval) {\n          rangeUtil.describeInterval(this.target.downsampleInterval);\n        } else {\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\n        }\n      } catch (err) {\n        errs.downsampleInterval = err.message;\n      }\n    }\n\n    if (this.target.tags && has(this.target.tags, this.target.currentTagKey)) {\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\n    }\n\n    return errs;\n  }\n}\n","import React, { SyntheticEvent } from 'react';\nimport { InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input } = LegacyForms;\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { OpenTsdbOptions } from '../types';\n\nconst tsdbVersions = [\n  { label: '<=2.1', value: 1 },\n  { label: '==2.2', value: 2 },\n  { label: '==2.3', value: 3 },\n];\n\nconst tsdbResolutions = [\n  { label: 'second', value: 1 },\n  { label: 'millisecond', value: 2 },\n];\n\ninterface Props {\n  value: DataSourceSettings<OpenTsdbOptions>;\n  onChange: (value: DataSourceSettings<OpenTsdbOptions>) => void;\n}\n\nexport const OpenTsdbDetails = (props: Props) => {\n  const { onChange, value } = props;\n\n  return (\n    <>\n      <h5>OpenTSDB settings</h5>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Version</InlineFormLabel>\n        <Select\n          menuShouldPortal\n          options={tsdbVersions}\n          value={tsdbVersions.find((version) => version.value === value.jsonData.tsdbVersion) ?? tsdbVersions[0]}\n          onChange={onSelectChangeHandler('tsdbVersion', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Resolution</InlineFormLabel>\n        <Select\n          menuShouldPortal\n          options={tsdbResolutions}\n          value={\n            tsdbResolutions.find((resolution) => resolution.value === value.jsonData.tsdbResolution) ??\n            tsdbResolutions[0]\n          }\n          onChange={onSelectChangeHandler('tsdbResolution', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Lookup limit</InlineFormLabel>\n        <Input\n          type=\"number\"\n          value={value.jsonData.lookupLimit ?? 1000}\n          onChange={onInputChangeHandler('lookupLimit', value, onChange)}\n        />\n      </div>\n    </>\n  );\n};\n\nconst onSelectChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  newValue: SelectableValue\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: newValue.value,\n    },\n  });\n};\n\nconst onInputChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './components/ConfigEditor';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(OpenTsDatasource)\n  .setQueryCtrl(OpenTsQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { OpenTsdbDetails } from './OpenTsdbDetails';\nimport { OpenTsdbOptions } from '../types';\n\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<OpenTsdbOptions>) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:4242\"\n        dataSourceConfig={options}\n        onChange={onOptionsChange}\n      />\n      <OpenTsdbDetails value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n"],"names":["OpenTsDatasource","DataSourceApi","constructor","instanceSettings","templateSrv","getTemplateSrv","super","this","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","lookupLimit","tagKeys","aggregatorsPromise","filterTypesPromise","query","options","start","convertToTSDBTime","range","raw","from","timezone","end","to","qs","each","targets","target","metric","push","convertTargetToQuery","queries","compact","isEmpty","of","data","groupByTags","filters","length","val","tagk","tags","key","filter","hide","performTimeSeriesQuery","pipe","catchError","err","error","message","map","response","metricToTargetMapping","mapMetricsToTargets","_map","metricData","index","_saveTagKeys","transformMetricData","annotationQuery","rangeRaw","eventList","aggregator","annotation","lastValueFrom","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","targetContainsTemplate","i","variableExists","Object","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","getBackendSrv","fetch","suggestTagKeys","Promise","resolve","aggregateTags","tag","_performSuggestQuery","_get","q","max","result","_performMetricKeyValueLookup","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","_performMetricKeyLookup","tagks","tagv","relativeUrl","params","headers","Authorization","metricFindQuery","interpolated","replace","reject","responseTransform","value","metricsQuery","match","tagNamesQuery","tagValuesQuery","tagNamesSuggestQuery","tagValuesSuggestQuery","testDatasource","status","getAggregators","isArray","sort","getFilterTypes","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars","clone","label","tagData","toPairs","has","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","angular","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","findIndex","every","tagV","tagK","includes","interpolateVariablesInQueries","date","roundUp","dateMath","valueOf","OpenTsQueryCtrl","QueryCtrl","$scope","$injector","errors","validateTarget","aggregators","fillPolicies","filterTypes","datasource","then","aggs","suggestMetrics","callback","getTextValues","suggestTagValues","targetBlur","refresh","metricFindResult","textUtil","addTag","addTagMode","currentTagKey","currentTagValue","removeTag","editTag","closeAddTagMode","addFilter","size","addFilterMode","currentFilterType","currentFilterGroupBy","currentFilter","currentFilterKey","currentFilterValue","groupBy","removeFilter","editFilter","fil","closeAddFilterMode","errs","shouldDownsample","rangeUtil","Select","Input","LegacyForms","tsdbVersions","tsdbResolutions","OpenTsdbDetails","props","onChange","className","InlineFormLabel","width","menuShouldPortal","find","version","onSelectChangeHandler","resolution","onInputChangeHandler","newValue","currentTarget","AnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigEditor","onOptionsChange","DataSourceHttpSettings","defaultUrl","dataSourceConfig","setAnnotationQueryCtrl"],"sourceRoot":""}